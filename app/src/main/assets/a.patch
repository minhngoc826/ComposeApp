Subject: [PATCH] add document file
---
Index: app/src/main/assets/update_lazy_list_and_conversation_full.patch
===================================================================
diff --git a/app/src/main/assets/update_lazy_list_and_conversation_full.patch b/app/src/main/assets/update_lazy_list_and_conversation_full.patch
deleted file mode 100644
--- a/app/src/main/assets/update_lazy_list_and_conversation_full.patch	(revision ba4c2466c1db856b381b0f51228eae550ca7b3fe)
+++ /dev/null	(revision ba4c2466c1db856b381b0f51228eae550ca7b3fe)
@@ -1,831 +0,0 @@
-Subject: [PATCH] update lazy list and conversation full
----
-Index: app/src/main/java/com/example/composeapp/theme/Theme.kt
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/theme/Theme.kt b/app/src/main/java/com/example/composeapp/theme/Theme.kt
-deleted file mode 100644
---- a/app/src/main/java/com/example/composeapp/theme/Theme.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ /dev/null	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-@@ -1,58 +0,0 @@
--package com.example.composeapp.theme
--
--import android.app.Activity
--import android.os.Build
--import androidx.compose.foundation.isSystemInDarkTheme
--import androidx.compose.material3.MaterialTheme
--import androidx.compose.material3.darkColorScheme
--import androidx.compose.material3.dynamicDarkColorScheme
--import androidx.compose.material3.dynamicLightColorScheme
--import androidx.compose.material3.lightColorScheme
--import androidx.compose.runtime.Composable
--import androidx.compose.ui.platform.LocalContext
--
--private val DarkColorScheme = darkColorScheme(
--    primary = Purple80,
--    secondary = PurpleGrey80,
--    tertiary = Pink80
--)
--
--private val LightColorScheme = lightColorScheme(
--    primary = Purple40,
--    secondary = PurpleGrey40,
--    tertiary = Pink40
--
--    /* Other default colors to override
--    background = Color(0xFFFFFBFE),
--    surface = Color(0xFFFFFBFE),
--    onPrimary = Color.White,
--    onSecondary = Color.White,
--    onTertiary = Color.White,
--    onBackground = Color(0xFF1C1B1F),
--    onSurface = Color(0xFF1C1B1F),
--    */
--)
--
--@Composable
--fun ComposeAppTheme(
--    darkTheme: Boolean = isSystemInDarkTheme(),
--    // Dynamic color is available on Android 12+
--    dynamicColor: Boolean = true,
--    content: @Composable () -> Unit
--) {
--    val colorScheme = when {
--        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
--            val context = LocalContext.current
--            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
--        }
--
--        darkTheme -> DarkColorScheme
--        else -> LightColorScheme
--    }
--
--    MaterialTheme(
--        colorScheme = colorScheme,
--        typography = Typography,
--        content = content
--    )
--}
-\ No newline at end of file
-Index: app/src/main/java/com/example/composeapp/ui/theme/Color.kt
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/ui/theme/Color.kt b/app/src/main/java/com/example/composeapp/ui/theme/Color.kt
-deleted file mode 100644
---- a/app/src/main/java/com/example/composeapp/ui/theme/Color.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ /dev/null	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-@@ -1,11 +0,0 @@
--package com.example.composeapp.ui.theme
--
--import androidx.compose.ui.graphics.Color
--
--val Purple80 = Color(0xFFD0BCFF)
--val PurpleGrey80 = Color(0xFFCCC2DC)
--val Pink80 = Color(0xFFEFB8C8)
--
--val Purple40 = Color(0xFF6650a4)
--val PurpleGrey40 = Color(0xFF625b71)
--val Pink40 = Color(0xFF7D5260)
-\ No newline at end of file
-Index: app/src/main/java/com/example/composeapp/ui/theme/Type.kt
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/ui/theme/Type.kt b/app/src/main/java/com/example/composeapp/ui/theme/Type.kt
-deleted file mode 100644
---- a/app/src/main/java/com/example/composeapp/ui/theme/Type.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ /dev/null	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-@@ -1,34 +0,0 @@
--package com.example.composeapp.ui.theme
--
--import androidx.compose.material3.Typography
--import androidx.compose.ui.text.TextStyle
--import androidx.compose.ui.text.font.FontFamily
--import androidx.compose.ui.text.font.FontWeight
--import androidx.compose.ui.unit.sp
--
--// Set of Material typography styles to start with
--val Typography = Typography(
--    bodyLarge = TextStyle(
--        fontFamily = FontFamily.Default,
--        fontWeight = FontWeight.Normal,
--        fontSize = 16.sp,
--        lineHeight = 24.sp,
--        letterSpacing = 0.5.sp
--    )
--    /* Other default text styles to override
--    titleLarge = TextStyle(
--        fontFamily = FontFamily.Default,
--        fontWeight = FontWeight.Normal,
--        fontSize = 22.sp,
--        lineHeight = 28.sp,
--        letterSpacing = 0.sp
--    ),
--    labelSmall = TextStyle(
--        fontFamily = FontFamily.Default,
--        fontWeight = FontWeight.Medium,
--        fontSize = 11.sp,
--        lineHeight = 16.sp,
--        letterSpacing = 0.5.sp
--    )
--    */
--)
-\ No newline at end of file
-Index: app/src/main/java/com/example/composeapp/conversation/ui/ConversationActivity.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/conversation/ui/ConversationActivity.kt b/app/src/main/java/com/example/composeapp/conversation/ui/ConversationActivity.kt
---- a/app/src/main/java/com/example/composeapp/conversation/ui/ConversationActivity.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/conversation/ui/ConversationActivity.kt	(date 1731428530308)
-@@ -9,8 +9,10 @@
- import androidx.compose.foundation.layout.Column
- import androidx.compose.foundation.layout.Row
- import androidx.compose.foundation.layout.Spacer
-+import androidx.compose.foundation.layout.WindowInsets
- import androidx.compose.foundation.layout.fillMaxSize
- import androidx.compose.foundation.layout.fillMaxWidth
-+import androidx.compose.foundation.layout.ime
- import androidx.compose.foundation.layout.imePadding
- import androidx.compose.foundation.layout.navigationBarsPadding
- import androidx.compose.foundation.layout.padding
-@@ -23,9 +25,9 @@
- import androidx.compose.material.icons.Icons
- import androidx.compose.material.icons.filled.KeyboardArrowDown
- import androidx.compose.material.icons.filled.Send
--import androidx.compose.material3.Divider
- import androidx.compose.material3.FabPosition
- import androidx.compose.material3.FloatingActionButton
-+import androidx.compose.material3.HorizontalDivider
- import androidx.compose.material3.Icon
- import androidx.compose.material3.IconButton
- import androidx.compose.material3.Scaffold
-@@ -37,10 +39,13 @@
- import androidx.compose.runtime.mutableStateOf
- import androidx.compose.runtime.remember
- import androidx.compose.runtime.rememberCoroutineScope
-+import androidx.compose.runtime.saveable.rememberSaveable
- import androidx.compose.runtime.setValue
- import androidx.compose.ui.Alignment
- import androidx.compose.ui.Modifier
- import androidx.compose.ui.graphics.Color
-+import androidx.compose.ui.platform.LocalDensity
-+import androidx.compose.ui.platform.LocalSoftwareKeyboardController
- import androidx.compose.ui.tooling.preview.Preview
- import androidx.compose.ui.unit.dp
- import androidx.compose.ui.unit.sp
-@@ -54,14 +59,14 @@
- import com.example.composeapp.common.SubScreen
- import com.example.composeapp.conversation.viewmodel.ConversationViewModel
- import com.example.composeapp.conversation.viewmodel.Message
--import com.example.composeapp.theme.ComposeAppTheme
-+import com.example.composeapp.common.theme.ComposeAppTheme
- import kotlinx.coroutines.CoroutineScope
- import kotlinx.coroutines.launch
- import java.util.Date
- 
- class ConversationActivity : ComponentActivity() {
-     companion object {
--        const val TAG = "BasicActivity"
-+        const val TAG = "ConversationActivity"
-     }
- 
-     private var messages = listOf<Message>() // empty list
-@@ -90,7 +95,8 @@
-     val curScreen = SubScreen.valueOf(navBackStackEntry?.destination?.route ?: SubScreen.APP_BASIC.name)
-     val scope = rememberCoroutineScope()
-     val lazyListState = rememberLazyListState()     // State hoisted to the ConversationScreen
--    val messages by conversationViewModel.messages.collectAsState(initial = emptyList())
-+    val isKeyboardVisible = WindowInsets.ime.getBottom(LocalDensity.current) > 0 // keyboard show or hide
-+    val keyboardController = LocalSoftwareKeyboardController.current
- 
-     Scaffold(
-         topBar = {
-@@ -106,7 +112,7 @@
-         },
-         floatingActionButton = {
-             JumpToBottom(
--                onClicked = { scope.launch { lazyListState.scrollToItem(0) } }
-+                onClicked = { scope.launch { lazyListState.scrollToItem(conversationViewModel.messages.size) } }
-             )
-         },
-         floatingActionButtonPosition = FabPosition.Center,
-@@ -116,7 +122,7 @@
-             .navigationBarsPadding()
-             .imePadding()
-     ) { innerPadding ->
--        Logger.d(ConversationActivity.TAG, "ConversationScreen: $innerPadding")
-+        Logger.d(ConversationActivity.TAG, "ConversationScreen: innerPadding = $innerPadding")
-         Column(
-             modifier = Modifier
-                 .fillMaxSize()
-@@ -137,7 +143,7 @@
-                     .background(color = Color.LightGray)
-                 ,
-                 scope = scope,
--                messages = messages,
-+                messages = conversationViewModel.messages,
-                 lazyListState = lazyListState
-             )     // Reuse same state in MessageList
- 
-@@ -153,12 +159,16 @@
-                 ,
-                 onMessageSent = {  text: String, time: String ->                        // Apply UI logic to lazyListState
-                     val newMessage = Message(
--                        channelId = messages.size.toString(),
-+                        channelId = (conversationViewModel.messages.size + 1).toString(),
-                         content = text,
-                         timestamp = time
-                     )
-+                    conversationViewModel.sendMessage(newMessage)      // Add message to ViewModel's LiveData
-+                    if (isKeyboardVisible) {
-+                        keyboardController?.hide()
-+                    }
- 
--                    scope.launch { lazyListState.scrollToItem(0) }
-+                    scope.launch { lazyListState.scrollToItem(conversationViewModel.messages.size) }
-                 }
-             )
-         }
-@@ -206,7 +216,7 @@
-     ) {
-         Text(text = "${message.content}", fontSize = 18.sp)
-         Text(text = "${message.timestamp}", fontSize = 12.sp)
--        Divider(
-+        HorizontalDivider(
-             modifier = Modifier.fillMaxWidth(),
-             thickness = 1.dp
-         )
-@@ -225,7 +235,7 @@
-         verticalAlignment = Alignment.CenterVertically,
-         horizontalArrangement = Arrangement.Center
-     ) {
--        var text by remember { mutableStateOf("") } // Remember a mutable state variable
-+        var text by rememberSaveable { mutableStateOf("") } // Remember a mutable state variable
-         TextField(
-             value = text,
-             onValueChange = { text = it },
-@@ -240,6 +250,8 @@
-             onClick = {
-                 val timestamp = Date(System.currentTimeMillis())
-                 onMessageSent(text, "" + timestamp.hours + ":" + timestamp.minutes)
-+                text = ""
-+                // check keyborad show/hide
-             }
-         ) {
-             Icon(imageVector = Icons.Filled.Send, contentDescription = "Send message", tint = androidx.compose.ui.graphics.Color.Blue)
-Index: app/src/main/java/com/example/composeapp/navigation/profile/ui/NavigationActivity.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/navigation/profile/ui/NavigationActivity.kt b/app/src/main/java/com/example/composeapp/navigation/profile/ui/NavigationActivity.kt
---- a/app/src/main/java/com/example/composeapp/navigation/profile/ui/NavigationActivity.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/navigation/profile/ui/NavigationActivity.kt	(date 1731406163922)
-@@ -30,7 +30,7 @@
- import com.example.composeapp.navigation.profile.ui.screen.LoginScreen
- import com.example.composeapp.navigation.profile.ui.screen.ProfileScreen
- import com.example.composeapp.navigation.profile.viewmodel.UserViewModel
--import com.example.composeapp.theme.ComposeAppTheme
-+import com.example.composeapp.common.theme.ComposeAppTheme
- 
- class NavigationActivity : ComponentActivity() {
-     companion object {
-Index: app/src/main/java/com/example/composeapp/ssm/ui/screen/SelectOsScreen.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/ssm/ui/screen/SelectOsScreen.kt b/app/src/main/java/com/example/composeapp/ssm/ui/screen/SelectOsScreen.kt
---- a/app/src/main/java/com/example/composeapp/ssm/ui/screen/SelectOsScreen.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/ssm/ui/screen/SelectOsScreen.kt	(date 1731396227742)
-@@ -23,7 +23,7 @@
- import androidx.compose.ui.unit.dp
- import androidx.compose.ui.unit.sp
- import com.example.composeapp.R
--import com.example.composeapp.theme.ComposeAppTheme
-+import com.example.composeapp.common.theme.ComposeAppTheme
- 
- @Composable
- fun SelectOsScreen(
-Index: app/src/main/java/com/example/composeapp/ssm/ui/screen/SearchingScreen.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/ssm/ui/screen/SearchingScreen.kt b/app/src/main/java/com/example/composeapp/ssm/ui/screen/SearchingScreen.kt
---- a/app/src/main/java/com/example/composeapp/ssm/ui/screen/SearchingScreen.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/ssm/ui/screen/SearchingScreen.kt	(date 1731396227736)
-@@ -20,7 +20,7 @@
- import androidx.compose.ui.unit.sp
- import androidx.navigation.NavHostController
- import com.example.composeapp.R
--import com.example.composeapp.theme.ComposeAppTheme
-+import com.example.composeapp.common.theme.ComposeAppTheme
- 
- @Composable
- fun SearchingScreen() {
-Index: app/src/main/java/com/example/composeapp/conversation/viewmodel/ConversationViewModel.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/conversation/viewmodel/ConversationViewModel.kt b/app/src/main/java/com/example/composeapp/conversation/viewmodel/ConversationViewModel.kt
---- a/app/src/main/java/com/example/composeapp/conversation/viewmodel/ConversationViewModel.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/conversation/viewmodel/ConversationViewModel.kt	(date 1731427378226)
-@@ -1,6 +1,8 @@
- package com.example.composeapp.conversation.viewmodel
- 
-+import androidx.compose.runtime.toMutableStateList
- import androidx.lifecycle.ViewModel
-+import com.example.composeapp.common.Logger
- import com.example.composeapp.conversation.data.LocalMessageDataSourceImpl
- import com.example.composeapp.conversation.data.MessageRepository
- import kotlinx.coroutines.flow.MutableStateFlow
-@@ -11,10 +13,24 @@
-     messageRepository: MessageRepository = MessageRepository(LocalMessageDataSourceImpl())
- ) : ViewModel() {
- 
--    private val _messages = MutableStateFlow(messageRepository.getListMessages(channelId))
--    val messages = _messages.asStateFlow() // TODO: 2021-08-09 replace with stateIn when it's available in compose
-+    // way 1: can not add new message / delete message
-+//    private var _messages = MutableStateFlow(messageRepository.getListMessages(channelId))
-+//    var messages = _messages.asStateFlow() // TODO: 2021-08-09 replace with stateIn when it's available in compose
-+//
-+//
-+//    fun sendMessage(message: Message) {
-+//        Logger.d("ViewModel", "sendMessage $message")
-+//        _messages.value.
-+//        messages.value.as
-+//    }
-+
-+    // way 2
-+    private val _messages = messageRepository.getLatestMessages(channelId).toMutableStateList() // mutableListOf<>().append { addAll() }
-+    val messages: List<Message>
-+        get() = _messages
- 
-     fun sendMessage(message: Message) {
--
-+        Logger.d("ViewModel", "sendMessage $message")
-+        _messages.add(message)
-     }
- }
-Index: app/src/main/java/com/example/composeapp/basic/lazylist/TaskViewModel.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/basic/lazylist/TaskViewModel.kt b/app/src/main/java/com/example/composeapp/basic/lazylist/TaskViewModel.kt
-new file mode 100644
---- /dev/null	(date 1731409673303)
-+++ b/app/src/main/java/com/example/composeapp/basic/lazylist/TaskViewModel.kt	(date 1731409673303)
-@@ -0,0 +1,35 @@
-+package com.example.composeapp.basic.lazylist
-+
-+import androidx.compose.runtime.toMutableStateList
-+import androidx.lifecycle.ViewModel
-+import com.example.composeapp.common.Logger
-+import kotlinx.coroutines.flow.MutableStateFlow
-+
-+class TaskViewModel() : ViewModel() {
-+
-+    // way 1
-+//    private val _tasks1 = getListTasks().toMutableStateList()                        //
-+//    private val _tasks = _tasks1
-+    // way 2
-+//    private val _tasks2 = mutableListOf<Task>().apply { addAll(getListTasks()) }    //
-+//    private val _tasks = _tasks2.toMutableStateList()
-+    // way 3
-+    private val _tasks3 = MutableStateFlow(getListTasks())              //
-+    private val _tasks = _tasks3.value.toMutableStateList()
-+
-+    val tasks: List<Task>
-+        get() = _tasks
-+
-+    fun removeTask(task: Task) {
-+        Logger.d(TAG, "removeTask: task: $task - size: ${tasks.size}")
-+        _tasks.remove(task)
-+    }
-+
-+    companion object {
-+        private const val TAG = "TaskViewModel"
-+    }
-+}
-+
-+private fun getListTasks() = List(30) { i -> Task(i, "Task # $i") }
-+
-+data class Task(val id: Int, val title: String)
-\ No newline at end of file
-Index: app/src/main/java/com/example/composeapp/basic/lazylist/BasicalScreen.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/basic/lazylist/BasicalScreen.kt b/app/src/main/java/com/example/composeapp/basic/lazylist/BasicalScreen.kt
-new file mode 100644
---- /dev/null	(date 1731399018293)
-+++ b/app/src/main/java/com/example/composeapp/basic/lazylist/BasicalScreen.kt	(date 1731399018293)
-@@ -0,0 +1,7 @@
-+package com.example.composeapp.basic.lazylist
-+
-+import androidx.compose.runtime.Composable
-+
-+@Composable
-+fun BaseScreen() {
-+}
-\ No newline at end of file
-Index: app/src/main/java/com/example/composeapp/conversation/data/LocalMessageDataSourceImpl.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/conversation/data/LocalMessageDataSourceImpl.kt b/app/src/main/java/com/example/composeapp/conversation/data/LocalMessageDataSourceImpl.kt
---- a/app/src/main/java/com/example/composeapp/conversation/data/LocalMessageDataSourceImpl.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/conversation/data/LocalMessageDataSourceImpl.kt	(date 1731427006802)
-@@ -15,7 +15,7 @@
- 
-     override fun getListMessages(channelId: String): List<Message> {
-         var messages = listOf<Message>()
--        for (i in 10..30) {
-+        for (i in 1..20) {
-             messages += Message(
-                 channelId = i.toString(),
-                 content = "Hello $i",
-@@ -27,7 +27,7 @@
- 
-     override fun getLatestMessages(channelId: String): List<Message> {
-         var messages = listOf<Message>()
--        for (i in 10..30) {
-+        for (i in 1..20) {
-             messages += Message(
-                 channelId = i.toString(),
-                 content = "Hello $i",
-Index: app/src/main/java/com/example/composeapp/basic/lazylist/BasicLazyListScreen.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/basic/lazylist/BasicLazyListScreen.kt b/app/src/main/java/com/example/composeapp/basic/lazylist/BasicLazyListScreen.kt
-new file mode 100644
---- /dev/null	(date 1731404443370)
-+++ b/app/src/main/java/com/example/composeapp/basic/lazylist/BasicLazyListScreen.kt	(date 1731404443370)
-@@ -0,0 +1,91 @@
-+package com.example.composeapp.basic.lazylist
-+
-+import androidx.compose.foundation.background
-+import androidx.compose.foundation.layout.Arrangement
-+import androidx.compose.foundation.layout.Column
-+import androidx.compose.foundation.layout.Row
-+import androidx.compose.foundation.layout.fillMaxSize
-+import androidx.compose.foundation.layout.fillMaxWidth
-+import androidx.compose.foundation.layout.imePadding
-+import androidx.compose.foundation.layout.navigationBarsPadding
-+import androidx.compose.foundation.layout.padding
-+import androidx.compose.foundation.layout.statusBarsPadding
-+import androidx.compose.foundation.lazy.LazyColumn
-+import androidx.compose.foundation.lazy.items
-+import androidx.compose.material.icons.Icons
-+import androidx.compose.material.icons.filled.Close
-+import androidx.compose.material3.Button
-+import androidx.compose.material3.Checkbox
-+import androidx.compose.material3.Divider
-+import androidx.compose.material3.Icon
-+import androidx.compose.material3.IconButton
-+import androidx.compose.material3.Text
-+import androidx.compose.runtime.Composable
-+import androidx.compose.runtime.getValue
-+import androidx.compose.runtime.mutableIntStateOf
-+import androidx.compose.runtime.mutableStateOf
-+import androidx.compose.runtime.remember
-+import androidx.compose.runtime.saveable.rememberSaveable
-+import androidx.compose.runtime.setValue
-+import androidx.compose.ui.Alignment
-+import androidx.compose.ui.Modifier
-+import androidx.compose.ui.unit.dp
-+import androidx.lifecycle.viewmodel.compose.viewModel
-+
-+@Composable
-+fun BasicLazyListScreen(
-+    taskViewModel: TaskViewModel = viewModel(),
-+    modifier: Modifier = Modifier
-+) {
-+    Column(
-+        modifier = modifier.fillMaxSize(),
-+        verticalArrangement = Arrangement.Top,
-+        horizontalAlignment = Alignment.Start
-+    ) {
-+        TaskCounter(modifier)
-+
-+        TaskList(taskViewModel.tasks, modifier = modifier.weight(1f), onCloseTask = { task -> taskViewModel.removeTask(task) })
-+    }
-+}
-+
-+@Composable
-+fun TaskCounter(modifier: Modifier) {
-+    Column(modifier = Modifier.fillMaxWidth().background(color = androidx.compose.ui.graphics.Color.LightGray).padding(start = 16.dp, end = 10.dp, top = 10.dp)) {
-+        var count by rememberSaveable { mutableIntStateOf(0) } //
-+
-+        Text(text = "You have $count tasks to do today!")
-+        Button(onClick = { count++ }, modifier = modifier.padding(8.dp)) {
-+            Text(text = "Add a task")
-+        }
-+    }
-+}
-+
-+@Composable
-+fun TaskList(tasks: List<Task>, modifier: Modifier, onCloseTask: (Task) -> Unit) {
-+    LazyColumn(modifier = modifier) {
-+        items(items = tasks, key = { task -> task.id }) {
-+            task -> TaskItem(task.title, modifier, onClose = { onCloseTask(task) }
-+            )
-+        }
-+    }
-+}
-+
-+@Composable
-+fun TaskItem(taskName: String, modifier: Modifier, onClose: () -> Unit) {
-+    var checkedState by rememberSaveable { mutableStateOf(false) }
-+
-+    Row(
-+        modifier = Modifier.fillMaxWidth().padding(start = 20.dp, end = 16.dp, top = 5.dp),
-+        verticalAlignment = Alignment.CenterVertically,
-+    ) {
-+        Text(text = taskName, modifier.weight(1f))
-+        Checkbox(
-+            checked = checkedState,
-+            onCheckedChange = { checkedState = it }
-+        )
-+
-+        IconButton(onClick = onClose) {
-+            Icon(imageVector = Icons.Filled.Close, contentDescription = "Close")
-+        }
-+    }
-+}
-Index: app/src/main/java/com/example/composeapp/MainActivity.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/MainActivity.kt b/app/src/main/java/com/example/composeapp/MainActivity.kt
---- a/app/src/main/java/com/example/composeapp/MainActivity.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/MainActivity.kt	(date 1731396227656)
-@@ -41,7 +41,7 @@
- import com.example.composeapp.common.SubScreen
- import com.example.composeapp.navigation.profile.ui.NavigationActivity
- import com.example.composeapp.ssm.ui.SsmActivity
--import com.example.composeapp.theme.ComposeAppTheme
-+import com.example.composeapp.common.theme.ComposeAppTheme
- 
- class MainActivity : ComponentActivity() {
-     companion object {
-Index: app/src/main/java/com/example/composeapp/basic/BasicActivity.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/basic/BasicActivity.kt b/app/src/main/java/com/example/composeapp/basic/BasicActivity.kt
---- a/app/src/main/java/com/example/composeapp/basic/BasicActivity.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/basic/BasicActivity.kt	(date 1731404092431)
-@@ -4,17 +4,31 @@
- import androidx.activity.ComponentActivity
- import androidx.activity.compose.setContent
- import androidx.activity.enableEdgeToEdge
--import androidx.compose.material3.Text
-+import androidx.compose.foundation.layout.fillMaxWidth
-+import androidx.compose.foundation.layout.imePadding
-+import androidx.compose.foundation.layout.navigationBarsPadding
-+import androidx.compose.foundation.layout.padding
-+import androidx.compose.foundation.layout.statusBarsPadding
-+import androidx.compose.material3.Scaffold
- import androidx.compose.runtime.Composable
--import androidx.compose.ui.res.stringResource
-+import androidx.compose.runtime.getValue
-+import androidx.compose.ui.Modifier
- import androidx.compose.ui.tooling.preview.Preview
--import com.example.composeapp.R
--import com.example.composeapp.theme.ComposeAppTheme
-+import androidx.navigation.NavHostController
-+import androidx.navigation.compose.NavHost
-+import androidx.navigation.compose.composable
-+import androidx.navigation.compose.currentBackStackEntryAsState
-+import androidx.navigation.compose.rememberNavController
-+import com.example.composeapp.basic.lazylist.BaseScreen
-+import com.example.composeapp.basic.lazylist.BasicLazyListScreen
-+import com.example.composeapp.common.MyTopAppBar
-+import com.example.composeapp.common.SubScreen
-+import com.example.composeapp.common.theme.ComposeAppTheme
- 
- class BasicActivity : ComponentActivity() {
-     override fun onCreate(savedInstanceState: Bundle?) {
--        enableEdgeToEdge()
-         super.onCreate(savedInstanceState)
-+        enableEdgeToEdge()
-         setContent {
-             ComposeAppTheme {
-                 BasicScreen()  // BasicScreen is a composable function that will be called when this activity is created.
-@@ -24,8 +38,37 @@
- }
- 
- @Composable
--fun BasicScreen() {
--    Text(text = stringResource(id = R.string.app_basic_screen))
-+fun BasicScreen(
-+    navHostController: NavHostController = rememberNavController()
-+) {
-+    val navBackStackEntry by navHostController.currentBackStackEntryAsState()
-+    val curScreen = SubScreen.valueOf(navBackStackEntry?.destination?.route ?: SubScreen.BASIC_LAZY_LIST.name)
-+
-+    Scaffold(
-+        topBar = {
-+            MyTopAppBar(
-+                curScreen = curScreen,
-+                canNavigateUp = navHostController.previousBackStackEntry != null,
-+                navigateUp = { navHostController.navigateUp() },
-+                modifier = Modifier.fillMaxWidth()
-+            )
-+        }
-+    ) { innerPadding ->
-+        NavHost(
-+            navController = navHostController,
-+            startDestination = SubScreen.BASIC_LAZY_LIST.name,
-+            modifier = Modifier.padding(innerPadding)
-+        ) {
-+            composable(route = SubScreen.BASIC_LAZY_LIST.name) {
-+                BasicLazyListScreen()
-+            }
-+
-+            composable(route = SubScreen.BASIC_BASIC.name) {
-+                BaseScreen()
-+            }
-+        }
-+
-+    }
- }
- 
- @Preview(showBackground = true)
-Index: app/src/main/java/com/example/composeapp/theme/Type.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/theme/Type.kt b/app/src/main/java/com/example/composeapp/common/theme/Type.kt
-rename from app/src/main/java/com/example/composeapp/theme/Type.kt
-rename to app/src/main/java/com/example/composeapp/common/theme/Type.kt
---- a/app/src/main/java/com/example/composeapp/theme/Type.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/common/theme/Type.kt	(date 1731396227608)
-@@ -1,4 +1,4 @@
--package com.example.composeapp.theme
-+package com.example.composeapp.common.theme
- 
- import androidx.compose.material3.Typography
- import androidx.compose.ui.text.TextStyle
-Index: app/src/main/java/com/example/composeapp/ui/theme/Theme.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/ui/theme/Theme.kt b/app/src/main/java/com/example/composeapp/common/theme/Theme.kt
-rename from app/src/main/java/com/example/composeapp/ui/theme/Theme.kt
-rename to app/src/main/java/com/example/composeapp/common/theme/Theme.kt
---- a/app/src/main/java/com/example/composeapp/ui/theme/Theme.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/common/theme/Theme.kt	(date 1731396227621)
-@@ -1,4 +1,4 @@
--package com.example.composeapp.ui.theme
-+package com.example.composeapp.common.theme
- 
- import android.app.Activity
- import android.os.Build
-Index: app/src/main/java/com/example/composeapp/theme/Color.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/theme/Color.kt b/app/src/main/java/com/example/composeapp/common/theme/Color.kt
-rename from app/src/main/java/com/example/composeapp/theme/Color.kt
-rename to app/src/main/java/com/example/composeapp/common/theme/Color.kt
---- a/app/src/main/java/com/example/composeapp/theme/Color.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/common/theme/Color.kt	(date 1731396227639)
-@@ -1,4 +1,4 @@
--package com.example.composeapp.theme
-+package com.example.composeapp.common.theme
- 
- import androidx.compose.ui.graphics.Color
- 
-Index: app/src/main/res/values/strings.xml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/res/values/strings.xml b/app/src/main/res/values/strings.xml
---- a/app/src/main/res/values/strings.xml	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/res/values/strings.xml	(date 1731397673844)
-@@ -16,4 +16,6 @@
-     <string name="nav_home_screen">Nav home screen</string>
-     <string name="nav_profile_screen">Nav profile screen</string>
-     <string name="nav_login_screen">Nav login screen</string>
-+    <string name="basic_basic_screen">Basical screen</string>
-+    <string name="basic_lazy_list_screen">Lazy list screen</string>
- </resources>
-\ No newline at end of file
-Index: app/src/main/java/com/example/composeapp/common/SubScreen.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/common/SubScreen.kt b/app/src/main/java/com/example/composeapp/common/SubScreen.kt
---- a/app/src/main/java/com/example/composeapp/common/SubScreen.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/common/SubScreen.kt	(date 1731398288288)
-@@ -21,6 +21,9 @@
- //    Navigation
-     NAV_HOME(titleId = R.string.nav_home_screen),
-     NAV_PROFILE(titleId = R.string.nav_profile_screen),
--    NAV_LOGIN(titleId = R.string.nav_login_screen)
-+    NAV_LOGIN(titleId = R.string.nav_login_screen),
- 
-+//    Basic
-+    BASIC_BASIC(titleId = R.string.basic_basic_screen),
-+    BASIC_LAZY_LIST(titleId = R.string.basic_lazy_list_screen),
- }
-\ No newline at end of file
-Index: app/src/main/java/com/example/composeapp/ssm/ui/screen/MainScreen.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/ssm/ui/screen/MainScreen.kt b/app/src/main/java/com/example/composeapp/ssm/ui/screen/MainScreen.kt
---- a/app/src/main/java/com/example/composeapp/ssm/ui/screen/MainScreen.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/ssm/ui/screen/MainScreen.kt	(date 1731396227731)
-@@ -24,7 +24,7 @@
- import androidx.compose.ui.unit.sp
- import com.example.composeapp.R
- import com.example.composeapp.common.SubScreen
--import com.example.composeapp.theme.ComposeAppTheme
-+import com.example.composeapp.common.theme.ComposeAppTheme
- 
- @Composable
- fun MainScreen(
-Index: app/src/main/java/com/example/composeapp/ssm/ui/screen/ConnectionScreen.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/ssm/ui/screen/ConnectionScreen.kt b/app/src/main/java/com/example/composeapp/ssm/ui/screen/ConnectionScreen.kt
---- a/app/src/main/java/com/example/composeapp/ssm/ui/screen/ConnectionScreen.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/ssm/ui/screen/ConnectionScreen.kt	(date 1731396227726)
-@@ -23,7 +23,7 @@
- import androidx.compose.ui.unit.dp
- import androidx.compose.ui.unit.sp
- import com.example.composeapp.R
--import com.example.composeapp.theme.ComposeAppTheme
-+import com.example.composeapp.common.theme.ComposeAppTheme
- 
- @Composable
- fun ConnectionScreen(
-Index: app/src/main/java/com/example/composeapp/ssm/ui/SsmScreen.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/ssm/ui/SsmScreen.kt b/app/src/main/java/com/example/composeapp/ssm/ui/SsmScreen.kt
---- a/app/src/main/java/com/example/composeapp/ssm/ui/SsmScreen.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/ssm/ui/SsmScreen.kt	(date 1731396227710)
-@@ -29,7 +29,7 @@
- import com.example.composeapp.ssm.ui.screen.SearchingScreen
- import com.example.composeapp.ssm.ui.screen.SelectOsScreen
- import com.example.composeapp.ssm.viewmodel.SsmViewModel
--import com.example.composeapp.theme.ComposeAppTheme
-+import com.example.composeapp.common.theme.ComposeAppTheme
- 
- /* Navigation-Compose
- * 1. NavController:     redirect composable (screen) to destination
-Index: app/src/main/java/com/example/composeapp/ssm/ui/SsmNewActivity.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/ssm/ui/SsmNewActivity.kt b/app/src/main/java/com/example/composeapp/ssm/ui/SsmNewActivity.kt
---- a/app/src/main/java/com/example/composeapp/ssm/ui/SsmNewActivity.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/ssm/ui/SsmNewActivity.kt	(date 1731396227706)
-@@ -12,7 +12,7 @@
- import androidx.compose.ui.Modifier
- import androidx.compose.ui.tooling.preview.Preview
- import androidx.lifecycle.enableSavedStateHandles
--import com.example.composeapp.theme.ComposeAppTheme
-+import com.example.composeapp.common.theme.ComposeAppTheme
- 
- class SsmNewActivity : ComponentActivity() {
- 
-Index: app/src/main/java/com/example/composeapp/ssm/ui/SsmActivity.kt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/app/src/main/java/com/example/composeapp/ssm/ui/SsmActivity.kt b/app/src/main/java/com/example/composeapp/ssm/ui/SsmActivity.kt
---- a/app/src/main/java/com/example/composeapp/ssm/ui/SsmActivity.kt	(revision a0e7cd54fe32efae155b2662df61f46b826d4ba3)
-+++ b/app/src/main/java/com/example/composeapp/ssm/ui/SsmActivity.kt	(date 1731396227701)
-@@ -3,7 +3,7 @@
- import android.os.Bundle
- import androidx.activity.ComponentActivity
- import androidx.activity.compose.setContent
--import com.example.composeapp.theme.ComposeAppTheme
-+import com.example.composeapp.common.theme.ComposeAppTheme
- 
- class SsmActivity : ComponentActivity() {
- 
Index: app/src/main/assets/ViewModel.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/ViewModel.txt b/app/src/main/assets/ViewModel.txt
new file mode 100644
--- /dev/null	(date 1731147577912)
+++ b/app/src/main/assets/ViewModel.txt	(date 1731147577912)
@@ -0,0 +1,142 @@
+// Summary:				https://developer.android.com/topic/libraries/architecture/viewmodel?hl=vi
+1. Lifecycle
+
+2. ViewModel:
+	- ViewModel -> ViewModelStoreOwner -> ViewModelStore <-- ViewModelProvider
+	- ViewModelProvider.Factory: pass params to ViewModel
+	- viewModelScope: ~ CoroutineScope & Closeable
+	
+	- MutableStateFlow(UiState).update { StateFlơ<UiState> -> copy }
+	- observer: uiState.collect {}, uiState.observer()
+
+
+
+1. Lifecycle
+	1.1. Class
+		- Lifecycle
+		
+		- LifecycleOwner:												-> Activity implement LifecycleOwner
+			+ public val lifecycle: Lifecycle
+			+ LifecycleOwner.lifecycleScope = lifecycle.coroutineScope
+			
+
+2. ViewModel
+	2.0. Ưu điểm: Ưu điểm chính của lớp này là khả năng lưu trạng thái vào bộ nhớ đệm và duy trì trạng thái đó khi có các thay đổi về cấu hình. 
+					Điều này có nghĩa là giao diện người dùng không phải tìm nạp lại dữ liệu khi di chuyển giữa các hoạt động hoặc áp dụng các thay đổi về cấu hình, chẳng hạn như khi xoay màn hình.
+		- caches sate:
+		- persists state through configuration changes:
+		
+		- Lớp này cho phép bạn duy trì trạng thái giao diện người dùng.
+		- Lớp này cung cấp quyền truy cập vào business logic.
+
+	2.1. Class
+
+		- ViewModel: 
+			+ class SampleViewModel: ViewModel() {}			// viewModel(modelClass) -> call ViewModelStoreOwner
+			+ methods:
+				- state:	private val _uiState: MutableStateFlow(UiState()) 
+							-> val uiState: SateFlow<UiState> = _uiState.asStateFlow() 
+							-> _uiState.update { currentState -> currentState.copy(params) }
+				- cleared():
+				
+			+ data class UiState(val params)
+		
+		
+		- ViewModelStoreOwner: 						-> Activity implement ViewModelStoreOwner;  // ComponentActivity, Fragment và NavBackStackEntry
+			+ val viewModelStore: ViewModelStore
+		
+		- ViewModelStore:
+			+ val map = mutableMapOf<String, ViewModel>()	// map(className, ViewModel)
+			
+		- ViewModelProvider: 
+			+ Access ViewModel -> ViewModelProvider(context, factory).get(SampleViewModel::class.java)  <-- create by ViewModelLazy <-- ComponentActivity.viewModels()
+			
+			+ ViewModelProvider.Factory: class SampleViewModel(name: String) : ViewModel() {} -> cần truyền tham số cho ViewModel thì dùng Factory
+				- class SampleViewModelFactory (val arg: String): ViewModelProvider.Factory {
+					override fun <T : ViewModel?> create(modelClass: Class<T>): T {
+						return   modelClass.getConstructor(String::class.java).newInstance(arg)
+					}
+				}
+				
+		
+	2.2. Lifecycle:
+		+ Activity: 	ComponentActivity		-> cleared when activity is destroyed(finished)
+		+ Fragment:		Fragment				-> cleared when fragment is detached
+		+ Composable: 	NavBackStackEntry		-> cleared when it is popedback from stack
+		
+		+ when new viewModel() -> pass ViewModelStoreOwner (Navigation destination, Navigation graph, activity, fragment, ...) -> scope of ViewModel = scope of ViewModelStoreOwner.Lifecycle, 
+				và vẫn nằm trong bộ nhớ cho đến khi ViewModelStoreOwner biến mất vĩnh viễn.
+		
+	2.3. Deploy
+		+ Observer: 
+			- way 1: viewModel.uiState.observer(viewLifecycleOwner, Observer<UiState>) { uiState -> // handle }
+			- way 2: viewModel.uiState.collect { }
+			
+		+ onCleared(): dọn dẹp
+			
+		+ Shared viewmodel from activity/fragments & fragments: by using ViewModel with scope Activity for Activity & fragments
+			- get ViewModel scope Activity from fragment: viewModel = activity?.let{ ViewModelProviders.of(it)[SharedViewModel::class.java] } ?: throw Exception("Activity is null")
+			
+		+ viewModelScope: là một CoroutineScope tích hợp sẵn tự động theo vòng đời của ViewModel
+			- change viewModelScope: chỉ nhận CoroutineScope trong hàm constructor, Khi ViewModelStoreOwner xoá ViewModel vào lúc kết thúc vòng đời, ViewModel cũng sẽ huỷ CoroutineScope
+			
+				+ class MyViewModel(private val coroutineScope: CoroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)) : ViewModel() {
+					// Other ViewModel logic ...
+
+					override fun onCleared() {
+						coroutineScope.cancel()
+					}
+				}
+				
+			- from Lifecycle ver 2.5: có thể truyền một hoặc nhiều đối tượng Closeable đến hàm khởi tạo của ViewModel. Closeable sẽ tự động đóng khi thực thể ViewModel bị xoá.
+			
+				+ class CloseableCoroutineScope(context: CoroutineContext = SupervisorJob() + Dispatchers.Main.immediate) : Closeable, CoroutineScope {
+					override val coroutineContext: CoroutineContext = context
+					override fun close() {
+						coroutineContext.cancel()
+				   }
+				}
+				
+				+ class MyViewModel(private val coroutineScope: CoroutineScope = CloseableCoroutineScope()) : ViewModel(coroutineScope) {
+					// Other ViewModel logic ...
+				}
+			
+		+ Jetpack Compose:
+			- 
+		
+		+ Coroutine:
+			- 
+			
+			
+	2.4. ViewModel Scope:
+		+ Each ViewModel is scoped to an object that implements the ViewModelStoreOwner interface
+		+ Java:				
+			- Any:			MyViewModel viewModel = new ViewModelProvider(this).get(MyViewModel.class);
+		+ Kotlin:
+			- Closest ViewModelStoreOwner:	
+				+ Kotlin:	val viewModel: MyViewModel by viewModels()				// scoped to Activity, Fragment, NavBackStackEntry
+				+ Compose:	viewModel: MyViewModel = viewModel()					// destination of a Navigation graph, the host Fragment, or the host Activity.			// need lib:  androidx.lifecycle:lifecycle-viewmodel-compose
+				+ Hilt:		hiltViewModel()
+				
+			- Any ViewModelStoreOwner:
+				+ Kotlin:	val viewModel: SharedViewModel by activityViewModels()				val viewModel: SharedViewModel by viewModels(ownerProducer = { requireParentFragment() } )
+				+ Compose:	viewModel: SharedViewModel = viewModel(viewModelStoreOwner = (context as Fragment).requireActivity() / requireParentFragment())
+				
+			- scope Navigation graph:
+				+ Kotlin:
+					- val viewModel: SharedViewModel by navGraphViewModels(R.id.nav_graph)											// val viewModel: SharedViewModel by hiltNavGraphViewModels(R.id.nav_graph)
+					- val viewModel: SharedViewModel by viewModels( { findNavController().getBackStackEntry(R.id.nav_graph) } )
+				+ Compose:
+					- composable("myScreen") { backStackEntry ->
+						// Retrieve the NavBackStackEntry of "parentNavigationRoute"
+						val parentEntry = remember(backStackEntry) {
+							navController.getBackStackEntry("parentNavigationRoute")
+						}
+						// Get the ViewModel scoped to the `parentNavigationRoute` Nav graph
+						val parentViewModel: SharedViewModel = viewModel(parentEntry)												// val parentViewModel: SharedViewModel = hiltViewModel(parentEntry)
+						// ...
+					}
+			
+				+ 
+			
+			
Index: app/src/main/assets/JetpackCompose.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/JetpackCompose.txt b/app/src/main/assets/JetpackCompose.txt
new file mode 100644
--- /dev/null	(date 1731568775126)
+++ b/app/src/main/assets/JetpackCompose.txt	(date 1731568775126)
@@ -0,0 +1,354 @@
+/////// Ưu điểm của Jetpack Compose
+- Dễ học: 			Jetpack Compose dễ học hơn so với các phương pháp xây dựng giao diện người dùng truyền thống cho Android.
+- Tăng năng suất: 	Jetpack Compose giúp bạn tăng năng suất bằng cách cho phép bạn xây dựng giao diện người dùng nhanh hơn và dễ dàng hơn.
+- Hiệu suất cao: 	Jetpack Compose được tối ưu hóa cho hiệu suất cao, qua đó, giúp ứng dụng của bạn chạy mượt mà hơn.
+
+/////// So sánh chi tiết sử dụng Jetpack Compose và không sử dụng Jetpack Compose trong lập trình Android
+1. Hiệu suất
+	- Khi sử dụng Jetpack Compose: 
+		+ Hiệu suất cao do được tối ưu hóa cho việc sử dụng GPU và CPU.
+		+ Giảm thiểu việc sử dụng bộ nhớ và tài nguyên hệ thống.
+		+ Mang lại trải nghiệm người dùng mượt mà và nhạy bén.
+	- Không sử dụng Jetpack Compose
+		+ Có thể thấp hơn do sử dụng các phương thức truyền thống như XML và ViewGroups.
+		+ Tiêu thụ nhiều bộ nhớ và tài nguyên hệ thống hơn.
+		+ Trải nghiệm người dùng có thể không mượt mà và nhạy bén như khi sử dụng Jetpack Compose.
+
+2. Tính linh hoạt
+	- Sử dụng Jetpack Compose: 
+		+ Cung cấp API trực quan và dễ sử dụng để xây dựng giao diện người dùng.
+		+ Hỗ trợ nhiều thành phần UI có sẵn và khả năng tạo thành phần UI tùy chỉnh.
+		+ Cho phép tạo giao diện người dùng phức tạp một cách dễ dàng.
+	- Không sử dụng Jetpack Compose:
+		+ Việc xây dựng giao diện người dùng có thể phức tạp và tốn thời gian hơn.
+		+ Khả năng tùy chỉnh giao diện người dùng bị hạn chế bởi các thành phần UI có sẵn trong XML.
+		+ Khó khăn trong việc tạo giao diện người dùng phức tạp.
+
+3. Khả năng bảo trì
+	- Sử dụng Jetpack Compose:
+		+ Code dễ đọc và dễ hiểu hơn do sử dụng cú pháp khai báo.
+		+ Dễ dàng sửa lỗi và bảo trì giao diện người dùng.
+		+ Giúp giảm thiểu code boilerplate.
+	- Không sử dụng Jetpack Compose:
+		+ Code có thể khó đọc và khó hiểu hơn do sử dụng XML và Java.
+		+ Việc sửa lỗi và bảo trì giao diện người dùng có thể khó khăn hơn.
+		+ Code có thể chứa nhiều boilerplate.
+
+4. Khả năng tương thích
+	- Sử dụng Jetpack Compose:
+		+ Hỗ trợ đa nền tảng (Android, iOS, Web) với Kotlin Multi Platform Mobile (KMM).
+		+ Cho phép chia sẻ code giao diện người dùng giữa các nền tảng.
+	- Không sử dụng Jetpack Compose:
+		+ Việc chia sẻ code giao diện người dùng giữa các nền tảng khó khăn hơn.
+		+ Cần viết code riêng cho từng nền tảng
+		
+////////// SUMMARY ////////////////////////////////////////////////////
+1. 
+
+////////// JetPackCompose ////////////////////////////////////////////////////
+1. Introduction
+
+2. UI architect
+	2.1. Lifecycle
+		- Lifecycle: Vòng đời của một thành phần kết hợp được xác định bằng những sự kiện sau: nhập thành phần Compose, kết hợp lại 0 lần trở lên và rời khỏi thành phần Compose.
+			+ Quá trình kết hợp lại thường được kích hoạt khi có thay đổi đối với đối tượng State<T>. Compose sẽ theo dõi quá trình thay đổi này, đồng thời chạy tất cả thành phần kết hợp 
+				trong thành phần Compose có khả năng đọc State<T> và bất kỳ thành phần kết hợp quá trình này gọi mà không thể bỏ qua.
+			
+			+ Quản lý state với subView (subComposable): 
+				- separate composables: 	define by location of call: if input of a location composable is not changed -> not recomposition
+				- similar composables:		(like list item: insert, delete, move item) -> location change -> wrong: kết hợp location + key of item (mã nhận dạng) -> if key of location change -> recomposition
+											for (movie in movies) {
+												key(movie.id) { // Unique ID for this movie
+													MovieOverview(movie)
+												}
+											}
+			
+			+ Skip recomposition:	if the inputs haven't changed
+				- not skip recomposition if function is:
+					+ annotated with @NonRestartableComposable hoặc @NonSkippableComposable
+					+ return value is not Unit
+					+ A required parameter is of a non-stable type
+				
+				- skip recomposition if input haven't changed ~ immutable:		https://developer.android.com/develop/ui/compose/lifecycle?hl=vi
+					+ @Stable
+					+ The result of equals for two instances will forever be the same for the same two instances.
+					+ If a public property of the type changes, Composition will be notified.
+					+ All public property types are also stable.
+
+	
+	2.2. Side-effects: change state outside of scope -> đảm bảo rằng công việc bạn thực hiện trong đó có liên quan đến giao diện người dùng và không làm hỏng luồng dữ liệu một chiều		// https://developer.android.com/develop/ui/compose/side-effects?hl=vi
+		- LaunchedEffect:			run suspend function in the scope of composable -> only using in a composable
+			+ khởi chạy một coroutine với khối mã được truyền dưới dạng tham số. Coroutine sẽ bị huỷ nếu LaunchedEffect thoát khỏi thành phần đó.									// LaunchedEffect(key=pulseRateMs) { TODO }
+			+ khi key changed -> coroutine hiện có sẽ bị huỷ và new suspend function sẽ được khởi chạy trong coroutine mới															// LaunchedEffect(true) {} ~ while(true) {}
+			
+			+ DisposableEffect:
+		
+		- rememberCoroutineScope:	run coroutine outside a composable, but scoped by composable -> if composable is destroy (leaves the composition) -> coroutine is cancled		// scope = rememberCoroutineScope() -> scope.launch {}
+		
+		- rememberUpdatedState:		>< LaunchedEffect: not restart effect when key changed:																							// val currentOnTimeout by rememberUpdatedState(onTimeout)	
+		
+		- DisposableEffect:			effects that require cleanup -> if key changed -> dispose = cleanup for current effect, reset by calling effect again.							// DisposableEffect(lifecycleOwner) { TODO onDispose {} }
+			+ lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current			val observer = LifecycleEventObserver { _, event -> TODO }			lifecycleOwner.lifecycle.addObserver(observer)		onDispose { lifecycleOwner.lifecycle.removeObserver(observer) }
+		
+		- SideEffect:				publish Compose state to non-Compose code = share Compose state with objects not managed by compose												// SideEffect { TODO }
+			+ guarantees that the effect executes after every successful recomposition.
+			
+		- produceState:				convert non-Compose state into Compose state -> launches a coroutine scoped to the Composition that can push values into a returned State		// produceState(initialValue = Result.Loading, keys=xxx) { TODO }
+		
+		- derivedStateOf:			convert one or multiple state objects into another state -> when state changed many times but UI don't changed much								// derivedStateOf { lazyListState.firstVisibleItemIndex > 0 }	~ distinctUntilChanged()
+			+  hao tốn nhiều tài nguyên, và bạn chỉ nên dùng để tránh việc kết hợp lại không cần thiết khi kết quả không thay đổi.
+			
+		- snapshotFlow: 			convert Compose's State into Flows	->  State<T> thành Flow																						// (snapshotFlow { stateObject }).map().distinctUntilChanged().filter().collect {}
+			+ Khi một trong các đối tượng State được đọc bên trong khối snapshotFlow thay đổi, Flow sẽ tạo ra giá trị mới cho bộ sưu tập của nó nếu giá trị mới không bằng giá trị được tạo ra trước đó (hành vi này tương tự như hành vi của Flow.distinctUntilChanged).
+			
+		- reset Effect:
+			+ LaunchedEffect, DisposableEffect, produceState: keys changed -> reset
+			+ if some key changed but state not changed: 	using rememberUpdatedState for key
+			
+	2.3. Phases:
+		- Android View:		data -> 				measure -> 	layout -> 						drawing -> 			UI
+		- Compose:			data -> composition -> 				layout (measure + location) -> 	drawing (Canvas) -> UI							
+			+ Cho phép dữ liệu truyền theo một hướng từ thành phần đến bố cục đến bản vẽ để tạo một khung (còn gọi là luồng dữ liệu một chiều). 
+				BoxWithConstraintsvà LazyColumn vàLazyRow là các trường hợp ngoại lệ đáng chú ý, trong đó thành phần của tệp con phụ thuộc vào giai đoạn bố cục của tệp mẹ.
+			+ composition: 	run Composables và cho ra một cấu trúc cây đại diện cho giao diện người dùng. Cây giao diện người dùng này bao gồm các nút bố cục chứa tất cả thông tin cần thiết cho các giai đoạn tiếp theo
+			+ layout:		tree UI -> Tập hợp các nút bố cục chứa tất cả thông tin cần thiết để quyết định kích thước và vị trí của từng nút trong không gian 2D. (note con measure w & h, tọa độ x & y -> report note cha -> note cha measure self)
+			+ draw:			cây được di chuyển từ trên xuống dưới và mỗi nút sẽ lần lượt vẽ chính nó trên màn hình
+		
+		- State reads:			import setter / getter
+			+ State<T> -> .value / var:
+				- val paddingState: MutableState<Dp> = 	remember { mutableStateOf(8.dp) } 		-> 		paddingState.value
+				- var padding: 		Dp by 				remember { mutableStateOf(8.dp) }		->		padding
+
+			+ Composition
+			+ Layout:			Layout, MeasureScope.measure, Modifier.offset
+			+ Draw:				Canvas(modifier = modifier) { }, Modifier.drawBehind và Modifier.drawWithContent
+			
+			+ Optimize:			
+	
+	2.4. Managing State:
+		- Composition: 
+			+ Init composition -> state changed -> recomposition
+		
+		- remember:	để lưu trữ đối tượng trong bộ nhớ		-> mutableStateOf & immutableStateOf
+		
+		- mutableStateOf: tạo ra MutableState<T> có thể quan sát. Đây là một loại đối tượng có thể quan sát được tích hợp với thời gian chạy Compose.
+			+ interface MutableState<T> : State<T> { override var value: T }
+			+ 3 way to declare MutableState:
+				- val mutableState 			= 	remember { mutableStateOf(default) }
+				- var value 				by 	remember { mutableStateOf(default) }
+				- val (value, setValue) 	= 	remember { mutableStateOf(default) }
+				
+				+ by: delegate -> require: 	import androidx.compose.runtime.getValue						import androidx.compose.runtime.setValue
+		
+		- rememberSaveable:
+			+ remember: 		save state in mem for recomposition, but not keep value if channge configuration 
+			+ rememberSaveable:	auto save state to Bundle
+				- rememberSaveable sẽ không giữ lại trạng thái nếu người dùng đóng hoàn toàn activity. 
+					Ví dụ: tính năng này không giữ lại trạng thái nếu người dùng vuốt activity hiện tại lên từ màn hình gần đây.
+			
+			+ Note: using ArrayList<T> hoặc mutableListOf() làm trạng thái trong Compose, người dùng sẽ thấy dữ liệu không chính xác hoặc lỗi thời trong ứng dụng của bạn. 
+				Khi thay đổi, các đối tượng có thể thay đổi và không thể quan sát (chẳng hạn như ArrayList hoặc một lớp dữ liệu có thể thay đổi) sẽ không kích hoạt việc tái 
+				cấu trúc và Compose sẽ không quan sát được những đối tượng này.
+				
+		- Other states: convert object to State<T> để các thành phần kết hợp có thể tự động kết hợp lại khi trạng thái thay đổi.
+			+ Flow: 		collectAsState()						// có sẵn trong compose-runtime, using cho mã không phụ thuộc vào nền tảng thay vì collectAsStateWithLifecycle, vốn chỉ dành cho Android.
+			+ Flow: 		collectAsStateWithLifecycle()			// need:		implementation("androidx.lifecycle:lifecycle-runtime-compose:2.8.7")	// FLow -> State, same collectAsState()
+			
+			+ LiveData: 	observeAsState()						// need:		implementation("androidx.compose.runtime:runtime-livedata:1.7.5")		// LiveData -> State: LiveData<T>.observeAsState()
+			+ RxJava2/3: 	subscribeAsState()						// need:		implementation("androidx.compose.runtime:runtime-rxjava2/3:1.7.5")		//  Single, Observable, Completable -> State
+			
+			
+		- State full:	using remember in @Composable																	@Composable <- -> View (Content)		// State ->, Event <-
+		
+		- State less:	~State hoisting: chuyển trạng thái lên trên -> save state in ViewModel		ViewModel 	<- -> 	@Composable <- -> View (Content)		// State ->, Event <-
+			+ Mô hình chung để di chuyển trạng thái lên trên trong Jetpack Compose là thay thế biến trạng thái bằng 2 tham số:
+			+ value: T: giá trị hiện tại để hiển thị
+			+ onValueChange: (T) -> Unit: một sự kiện yêu cầu thay đổi giá trị này, trong đó T là giá trị mới được đề xuất
+			+ Ưu điểm:
+				- Single source of truth: 		Bằng cách di chuyển trạng thái thay vì sao chép, chúng tôi đảm bảo rằng chỉ có một nguồn thông tin duy nhất. Điều này giúp tránh các lỗi.
+				- Được đóng gói (encapsulated): Chỉ các thành phần kết hợp có trạng thái mới có thể sửa đổi trạng thái của chúng. Nó có tính nội bộ hoàn toàn.
+				- Có thể chia sẻ (shareable): 	Bạn có thể chia sẻ trạng thái được di chuyển lên trên với nhiều thành phần kết hợp. Nếu bạn muốn đọc name trong một thành phần kết hợp khác, việc di chuyển trạng thái lên trên sẽ cho phép bạn làm việc đó.
+				- Có thể chắn (interceptable): 	phương thức gọi đến các thành phần kết hợp không trạng thái có thể quyết định bỏ qua hoặc sửa đổi các sự kiện trước khi thay đổi trạng thái.
+				- Được tách riêng (decoupled): 	trạng thái của các thành phần kết hợp không có trạng thái có thể được lưu trữ ở bất cứ đâu. Ví dụ: bạn hiện có thể di chuyển name sang ViewModel.
+				
+			+ Vị trí chuyển state: https://developer.android.com/develop/ui/compose/state-hoisting?hl=vi#plain-state
+				
+		- Restoring state in Compose:
+			+ remember:				
+			+ rememberSaveable:		save state to bundle		<onConfigChanged|localizeChanged|darkMode>		remember
+			+ not save to Bundle:	using with rememberSaveable
+				- Parcelize:		@Parcelize	data class City(val name: String, val country: String) : Parcelable		// The object becomes parcelable, and can be bundled.
+									var selectedCity = rememberSaveable { mutableStateOf(City("Madrid", "Spain")) }
+									
+				- MapSaver:			val CitySaver = run {																// define rule for converting an object into a set of values that the system can save to the Bundle
+										val nameKey = "Name"
+										val countryKey = "Country"
+										mapSaver(
+											save = { mapOf(nameKey to it.name, countryKey to it.country) },
+											restore = { City(it[nameKey] as String, it[countryKey] as String) }
+										)
+									}
+									var selectedCity = rememberSaveable(stateSaver = CitySaver) { mutableStateOf(City("Madrid", "Spain")) }
+									
+				- ListSaver:		val CitySaver = listSaver<City, Any>(												// To avoid needing to define the keys for the map
+										save = { listOf(it.name, it.country) },
+										restore = { City(it[0] as String, it[1] as String) }
+									)
+									var selectedCity = rememberSaveable(stateSaver = CitySaver) { mutableStateOf(City("Madrid", "Spain")) }
+
+		- State holders in Compose:  	~ hoisted state object: manage logic and state of composables.
+			+ Holders business logic:	ViewModel, có thể tích hơp với Navigation -> uiState
+			+ Holders UI logic:			remember, rememberSaveable[ rememberScaffoldState() / rememberLazyListState() / rememberNavController() ] 		- do lib cung cấp
+										và các object state khác chỉ liên quan đến UI: navController, WindowSizeClass, ...								- custome state 		// https://developer.android.com/topic/architecture/ui-layer/stateholders?hl=vi#choose_between_a_viewmodel_and_plain_class_for_a_state_holder
+			+ suspens function:			1 số hàm suspend có scope ViewModelScope throw IllegalStateException (MonotonicFrameClock) khi gọi từ Compose UI --> using CoroutineScop of UI = rememberCoroutineScope() 		// LazyListState.animateScrollTo() and DrawerState.close().
+										fun closeDrawer(uiScope: CoroutineScope) { // ViewModel side							// Composable side: uiScope = rememberCoroutineScope()
+											viewModelScope.launch {
+												withContext(uiScope.coroutineContext) { // Use instead of the default context
+													drawerState.close()					// LazyListState.animateScrollTo()
+												}
+											}
+										}
+			
+		- Remember state with key: value only changed when key changed, if key is not changed, not need calculate again for state
+			+ remember(key1 = avatarRes) / remember(windowSizeClass):		key = avatarRes, windowSizeClass
+		
+		- Save UI state : reboot, system kill, recent, Configuration changes, User kill					// https://developer.android.com/develop/ui/compose/state-saving?hl=vi
+			+ UI State:		rememberSaveable
+				- primitive types:		remember / rememberSaveable
+				- Object:				@Parcelize, ListSaver, MapSaver, @Saver custom					// LazyListState using LazyListState.Saver: hold scroll state
+					+ @Composable
+					fun rememberLazyListState(
+						initialFirstVisibleItemIndex: Int = 0,
+						initialFirstVisibleItemScrollOffset: Int = 0
+					): LazyListState {
+						return rememberSaveable(saver = LazyListState.Saver) {
+							LazyListState(
+								initialFirstVisibleItemIndex, initialFirstVisibleItemScrollOffset
+							)
+						}
+					}
+					
+				- rememberSaveable /  onSaveInstanceState(): save ui state to Bundle -> TransactionTooLarge in runtime if using single activity -> bạn không nên lưu trữ các đối tượng vừa lớn lại vừa phức tạp hoặc không nên lưu trữ danh sách đối tượng trong gói. 
+																																					Thay vào đó, hãy lưu trữ trạng thái tối thiểu cần thiết, chẳng hạn như mã nhận dạng hoặc khoá
+				- Testing:	
+					+ StateRestorationTester:
+			
+			+ Logic business:	
+				- SavedStateHandle: ViewModel save state but can not save if system kill, user kill, power off, reboot -> using SavedStateHandle: 	var filteredData: List<String> by savedStateHandle.saveable { mutableStateOf(emptyList()) } // class SavedStateViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() {}
+					+ Dữ liệu có trong SavedStateHandle được lưu và khôi phục dưới dạng Bundle cùng với phần còn lại của savedInstanceState cho activity / fragment: primitive type, @Parcelable, Serializable, Binder, Bundle, ArrayList, Size / SizeF
+					+ setSavedStateProvider():	using SavedStateProvider  to set/get state 					https://developer.android.com/topic/libraries/architecture/viewmodel/viewmodel-savedstate?hl=vi#savedstate-compose-state
+					+ Testing: @Before
+								fun setup() {
+									val savedState = SavedStateHandle(mapOf("someIdArg" to testId))
+									viewModel = MyViewModel(savedState = savedState)
+								}
+					+ API:	
+						- SavedStateHandle.saveable()		 	= Compose state (MutableState)				var message by savedStateHandle.saveable(stateSaver = TextFieldValue.Saver) { mutableStateOf(TextFieldValue("")) }
+						- SavedStateHandle.getStateFlow()		= StateFlow									private val savedFilterType: StateFlow<ChannelsFilterType> = savedStateHandle.getStateFlow(key = CHANNEL_FILTER_SAVED_STATE_KEY, initialValue = ChannelsFilterType.ALL_CHANNELS )
+			
+			+ 1. Viewmodel
+			+ 2. Save state:
+				- Jetpack Compose: rememberSaveable.													//  primitive types
+				- Khung hiển thị (View): API onSaveInstanceState().
+				- ViewModel: SavedStateHandle.															// https://developer.android.com/topic/libraries/architecture/saving-states
+			+ 3. Local storage: db, share preference
+			+ 4. SavedStateRegistry:	Activity, Fragment													// https://developer.android.com/topic/libraries/architecture/saving-states?hl=vi#onsaveinstancestate
+			
+
+4. App Layout
+	- Flow Layout:
+
+
+5. View
+	+ TopAppBar:	ContainerHeight default = 64.dp, is set by TopAppBarTokens (internal object)
+		- TabLayout: val selectedTabId 	- 	TabRow(tabs = { Tab(icon=) Tab(icon=) } )
+	
+
+
+20. Compose and other libs:		https://developer.android.com/develop/ui/compose/libraries?hl=vi#streams
+	- Compose & Activity:		use ComponentActivity to using Compose in Activity
+		+ ComponentActivity:	lớp con của Activity cung cấp LifecycleOwner thích hợp và các thành phần cho Compose. 
+								Lớp con này cũng cung cấp các API bổ sung giúp tách mã khỏi các phương thức ghi đè trong lớp hoạt động của bạn. 
+								Activity Compose hiển thị những API này với các thành phần kết hợp sao cho không cần phải ghi đè những phương thức diễn ra bên ngoài các thành phần kết hợp hoặc truy xuất một thực thể Activity rõ ràng. 
+								Thêm vào đó, các API này đảm bảo chúng chỉ được khởi chạy một lần, duy trì quá trình tái cấu trúc, đồng thời dọn dẹp đúng cách nếu thành phần kết hợp bị xoá khỏi cấu trúc.
+								
+		+ rememberLauncherForActivityResult()
+		
+	- Permission: 				RequestPermission / RequestMultiplePermissions
+	
+	- Back press:				BackHandler(backHandlingEnabledBoolean) { // Handle back press }
+	
+	- ViewModel:				using viewModel() with gradle: 			implementation 'androidx.lifecycle:lifecycle-viewmodel-compose:2.8.5'  -> default: trả về một ViewModel hiện có hoặc tạo một ViewModel mới
+		+ Scope:				scope of caller (activity, fragment, navigation) -> đồng thời được giữ lại chừng nào phạm vi còn hoạt động.
+		+ Nếu ViewModel có các phần phụ thuộc, viewModel() sẽ lấy ViewModelProvider.Factory tuỳ ý làm tham số
+		
+	- Other types:
+		+ LiveData.observeAsState():		androidx.compose.runtime:runtime-livedata:$composeVersion
+		+ Flow.collectAsState():			not need lib
+		+ Observable.subscribeAsState():	
+		+ Observable.subscribeAsState():	androidx.compose.runtime:runtime-rxjava2/3:$composeVersion
+		
+	- Synchronize:				by using coroutine: LaunchedEffect, produceState và rememberCoroutineScope
+	
+	- Navigation:				NavHostController / NavHost
+	
+	- Hilt:						@HiltViewModel		implementation 'androidx.hilt:hilt-navigation-compose:1.2.0'
+		+ Hilt vs Navigation:						implementation 'androidx.hilt:hilt-navigation-compose:1.2.0'
+			NavHost(navController, startDestination = startRoute) {
+				composable("example") { backStackEntry ->
+					// Creates a ViewModel from the current BackStackEntry
+					// Available in the androidx.hilt:hilt-navigation-compose artifact
+					val viewModel = hiltViewModel<MyViewModel>()
+					MyScreen(viewModel)
+				}
+				// for parent
+				composable("exampleWithRoute") { backStackEntry ->
+					val parentEntry = remember(backStackEntry) {
+						navController.getBackStackEntry(route = "Parent")
+					}
+					val parentViewModel = hiltViewModel<ParentViewModel>(parentEntry)
+					ExampleWithRouteScreen(parentViewModel)
+				}
+			}
+	
+	- Paging:
+		+ flow: Flow<PagingData<String>>: 		flow.collectAsLazyPagingItems()
+		
+	
+	- Maps:		để tích hợp Google Maps								https://developers.google.com/maps/documentation/android-sdk/maps-compose?hl=vi
+		+ 
+	
+///////////////
+LaunchedEffect / DisposableEffect.
+WindowSizeClass
+derivedStateOf:		https://medium.com/androiddevelopers/jetpack-compose-when-should-i-use-derivedstateof-63ce7954c11b
+lazyListState
+@Stable:			https://medium.com/androiddevelopers/jetpack-compose-stability-explained-79c10db270c8		LazyListState
+snapshotFlow 
+
+internal object
+sealed class
+
+
+Bạn có thể sử dụng từ khoá by để xác định count dưới dạng một var. Việc thêm lệnh nhập getter và setter của phần tử uỷ quyền cho phép chúng ta đọc và thay đổi count 
+	một cách gián tiếp mà không cần tham chiếu rõ ràng đến thuộc tính value của MutableState mọi lần.
+
+// keyboard show/hide:  android:windowSoftInputMode="adjustResize" & Modifier.imePadding()
+
+@HiltViewModel
+class AuthorViewModel @Inject constructor(
+    savedStateHandle: SavedStateHandle,
+    private val authorsRepository: AuthorsRepository,
+    newsRepository: NewsRepository
+) : ViewModel() {
+
+    val uiState: StateFlow<AuthorScreenUiState> = …
+
+    // Business logic
+    fun followAuthor(followed: Boolean) {
+      …
+    }
+}
+
+		
+		
\ No newline at end of file
Index: app/src/main/assets/5.AndroidBuild.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/5.AndroidBuild.txt b/app/src/main/assets/5.AndroidBuild.txt
new file mode 100644
--- /dev/null	(date 1729883474756)
+++ b/app/src/main/assets/5.AndroidBuild.txt	(date 1729883474756)
@@ -0,0 +1,1 @@
+https://developer.android.com/build?hl=vi
\ No newline at end of file
Index: app/src/main/assets/AndroidDoc/05.Basic_Notification.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/AndroidDoc/05.Basic_Notification.java b/app/src/main/assets/AndroidDoc/05.Basic_Notification.java
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/AndroidDoc/05.Basic_Notification.java	(date 1731353706000)
@@ -0,0 +1,1 @@
+// 5.Notification.java
Index: app/src/main/assets/KotlinDoc/Kotlin.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/KotlinDoc/Kotlin.txt b/app/src/main/assets/KotlinDoc/Kotlin.txt
new file mode 100644
--- /dev/null	(date 1730813225801)
+++ b/app/src/main/assets/KotlinDoc/Kotlin.txt	(date 1730813225801)
@@ -0,0 +1,1060 @@
+1. Basic
+
+1.0 Keywords
+
+	- Hard Keywords
+		as		class		break		continue		do			else
+		for		fun			false		if				in			interface
+		super	return		object		package			null		is
+		try		throw		true		this			typeof		typealias
+		when	while		val			var
+
+	- Soft Keywords
+		+ By, Catch, Get, Finally, Field
+
+
+1.1. Data: not contains primity Data, all variable are Object data, kế thừa từ lớp Any -> can using generic: call function, property, assign to null
+	- Integers: 	Byte, Short, Int, Long  ------------ Byte-8, Short-16, Int-32, Long-64, Float-32, Double-64
+	- Unsigned integers:	UByte, UShort, UInt, ULong
+	- Floating-point numbers: Float, Double
+	- Bool: 		Boolean
+	- Character: 	Char	''			// ko đc xem là kiểu số như Java nữa, vì nó là object
+	- Text:			String	""
+	- Unit:			kiểu DL trả về mặc định cho tất cả các hàm của kotlin
+	
+	
+	- Type inference: tự suy ra kiểu biến
+	- constant literal:
+		val int = 123
+		val long = 123456L
+		val double = 123.45
+		val float = 123.45F
+		val hexa = 0xAB
+		val binary = 0b0001
+		
+	- from kotlin 1.1: using '_' for long number
+		val million = 1_000_000
+		val billion = 1_000_000_000L
+		
+	- Explicity conversion (Chuyển đổi kiểu tường minh):
+		+ toInt(), toFloat(), toChar(), ...
+	
+	- String: immutable, arrayOf characters -> str[idx] = char
+		+ String Literals: 	"one_line", """multi_line"""
+		+ String template:	"xxx ${string_var}"
+
+
+1.2. Type Casting
+	- num.toLong();  // toInt(), toFloat(), toChar()
+	- chú ý kết quả sẽ bị cắt ngắn (bị sai) nếu chuyển đổi sang kiểu DL nhỏ hơn nếu value ko nằm trong phạm vi của KDL mới)
+	- 'as' / 'as?': 
+		+ val t: String = y as String: throw ClassCastException if y = null -> to avoid Exception: val t: String? = y as String?
+		+ Safe cast: val s4: String? = s5 as? String
+	- Smart casting: Trong một số trường hợp, chúng ta không phải cast một cách tường minh vì compiler sẽ track việc check kiểu bằng is và sẽ tự động cast nếu cần:
+
+
+1.3. Toán tử
+	- 1 ngôi: 	+, -  	= 	.unaryPlus()/.unaryMinus()
+	- số học:	+, -, x, :, %		=	.plus() / .minus() / .times() / .div() / .rem()
+	- So sánh: 	
+		+ ==, !=  		~ 	.equals();	
+		+ >, <, >=, <= 	~	.compareTo()
+	- Logic:	&&, ||	~ 	.and(), .or()
+	- Tăng, giảm: ++, -- ~ 	.inc(), .dec()
+	- Basic:	Same Java
+	- Ranges:	x..y = [x, ..., y]
+	- Bitwise:
+		+ not: 	.inv()  // Inversion
+		+ and: 	.and()
+		+ or:	.or()
+		+ xor:	.xor()
+		
+	- '==' và '===': 	'!==' vs '!='
+		+ '==': 	a == b khi a, b khác null và có giá trị bằng nhau. 	// a == b <-> a?equals(b) ?: (b===null)
+		+ '===':	a === b khi a, b cùng trỏ đến cùng 1 object
+			- bình thường, number được lưu trữ một cách vật lý như kiểu dữ liệu nguyên thủy của JVM trừ khi chúng ta cần biến đó có thể gán được bằng null (VD: Int?) hoặc có thể sử dụng với generic. 
+				Trong trường hợp đó, number sẽ được boxing - tức là tự wrap kiểu nguyên thủy đó để nó trở thành kiểu Object.
+				Note: khi boxing, định danh của number không nhất thiết được giữ lại
+			- Tuy nhiên, với các giá trị từ 0 -> 127 (2^7 - 1), các đối tượng này sẽ được lưu trong cùng một vùng nhớ. Với các giá trị lớn hơn mốc 127 này, vì boxing, các định danh sẽ không được giữ lại
+		+ a == null <-> a === null
+	
+	- Toán tử elvis: ?:
+		+ val l = b?.length ?: -1 		// l = b.length if b != null else -1
+		
+	- Toán tử !! (null check)
+		+ val l = b!!.length		// Với !!, nếu b không null, l = b.length. Nếu b null, NPE sẽ được throw
+
+	
+1.4. Define Data
+	- syntax:		var/val name: <dataType> = value;
+	- var: Mutable = read + write
+	- val: Immutable = only read, can not re-assign
+	- Khai báo rồi gán sau: bắt buộc khai báo kiểu dữ liệu của biến:
+		+ var myName: String
+		+ myName = "Ngoc"
+
+	- Nullable: ?		var str: String? = readLine()
+
+	- String:
+		+ """ multi lines string """
+		+ .length, .charAt(), .subSquence(), .contains()
+		+ .equals(), compareTo()
+
+	- Array:
+		+ hỗn hợp: var arr = arrayOf(10, "BeginnersBook", 10.99, 'A');
+		+ var arr2 = arrayOf<String>("ab", "bc", "cd"); intArrayOf(); var arr3: IntArray = IntArray(n)
+		+ arrays.size, array[idx], array.get()/set(), array.contains(), .first(), .last(), .indexOf(), array.filter{}
+		+ Array là 1 đại lượng bất biến, không thể gán 1 Array<String> cho 1 Array<Any>.
+		+ để giảm bớt chi phí boxing, có các loại arrays sau (nhưng ko extend từ Array): ByteArray, ShortArray, IntArray
+
+	- Ranges:
+		+ for (num in 1..10)
+		+ check item: num in ranges
+		+ 1..10 = 1.rangeTo(10); 10..1 = 10.downTo(1), .reverse()
+		+ 1..10.step(3) = 1, 4, 7, 10
+
+	- Collections: Lists, Sets, Maps
+		+ Mutable Collections: can change size, item 			~	MutableList<Int> = mutableListOf()
+		+ Immutable Collections: can not change size, item		~	List<Int> = listOf() - read only
+		+ assign Immutable to the Mutable: cast Mutable to Immutable
+		
+		+ Lists: Ordered collections of items
+			- create: 	listOf() / mutableListOf()
+			- items: 	list[idx] / .first() / .last() / .count() / .add() / .remove()
+			- for: 		for item in list
+			
+		+ Sets: Unique unordered collections of items
+			- create:	setOf() / mutableSetOf()
+			- items: 	.count() / .add() / .remove()
+			- for:		in -> for item in set
+		
+		+ Maps: Sets of key-value pairs where keys are unique and map to only one value
+			- create:	mapOf() / mutableMapOf()			// mapOf("apple" to 100, "kiwi" to 190, "orange" to 120)
+			- items: 	value = map[key] / .count() / .put() / .remove() / .containsKey() / list = .keys / .values / 
+			- for:		in -> for item in set
+			
+		
+	- Matrix: 
+		+ var M: Array<IntArray> = Array(10,{IntArray(5)})
+		
+	- Type Inference
+		+ fun sumOf(a: Int, b: Int) = a + b
+		+ val a = 10     // kiểu Int
+			val b = 10L    // kiểu Long
+			val c = 10.1   // kiểu Double
+			val d = 10.1f  // kiểu Float
+			val e = true   // kiểu Boolean
+			val f = '$'    // kiểu Char
+			val g = "Minh" // kiểu String
+			
+	- Type check: if (obj is String) / if (obj !is String)
+	
+	- Iterator:
+		+ Có một member hoặc extension function tên là iterator(), kiểu trả về là Iterator
+			- Có một member hoặc extension function next()
+			- Có một member hoặc extension function hasNext trả về kiểu Boolean Tất cả 3 function này đều cần được đánh dấu là operator
+		+ Ex:
+			class DateRange(start: Int, val end: Int) {
+				var current = start
+
+				operator fun iterator(): Iterator<Int> {
+				  return object : Iterator<Int> {
+					  override fun next(): Int {
+						  val result = current
+						  current++
+						  return result
+					  }
+
+					  override fun hasNext(): Boolean {
+						  return current <= end
+					  }
+					}
+				}
+			}
+	
+1.5. Control flow
+	- if:						if() {} else {}
+		+ Trong Kotlin, if là một biểu thức, Bởi vậy, Kotlin không còn toán tử 3 yếu tố như Java: int a = result? 1 :0;
+		+ Nếu sau if là khối lệnh, giá trị ở cuối khối lệnh là giá trị trả về. Khi gán giá trị = if, nhánh else bắt buộc phải có
+		+ Conditional expressions: 	a = if (c > 5) b else d
+		+ gán: var x = if (y) { a } else { b }
+
+	- when (type) {		// điều kiện của when có thể là constant, function, range, kiểu DL
+		  type1  	-> value1	//~ switch case, return result, ~ if else, val result = when() {}
+		  ...................
+		  type9, type10 -> value9_10
+		  ...................
+		  else 		-> value
+	  }
+		+ gán: var x = when (type) {}
+
+	- for: 	+ for (num in a..b)				for (i in a until b)= [a,., b)		for (i in a..b step x)						for (i in a downTo b step x)	
+			+ for (str in array) 			for (i in array.indices) 			for ((idx, value) in array.withIndex())		for (item: Int in ints)
+
+	- while, do - while: same java
+
+	- continue, break, return: same java, áp dụng cho vòng lặp / funtion gần nhất
+		+ continue/break label: labelName@ for/forEach -> continue@labelName / break@labelName
+		+ return label:
+
+	- Comment:		// one line , /* multi lines */
+	- Comment KDoc Syntax: by Dokka tool ( https://github.com/Kotlin/dokka/blob/master/README.md)
+	+ @author : tác giả
+	+ @sample: Ví dụ
+	+ @param : parameter trong hàm
+	+ @return : kết quả trả về của hàm	+ 
+
+
+1.6. Read Input / file
+	- readLine(): 		return String or null -> cast to other dataType
+	- readLine(): 		return String or null -> cast to other dataType
+	- Scanner:			Scanner(System.'in').nextInt(); // .nextFloat(), ...
+	- print(), println()
+
+
+1.7. Exception
+	+ Tất cả các class exception trong Kotlin đều thừa kế từ lớp Throwable. Mọi exception đều có một message, stack trace và một optional cause	
+		- try {} catch(e: Exception) finally {}
+		- throw Exception("ex")
+	
+	+ try = expression: return value in block try{} or catch{}, not in finally{}
+		- val a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }
+	
+	+ Nothing Type:
+		- throw là một biểu thức trong Kotlin, bởi vậy chúng ta có thể sử dụng throw như một phần của toán tử elvis:
+			+ val s = person.name ?: throw IllegalArgumentException("Name required")
+		
+		- Kiểu dữ liệu của biểu thức throw là một kiểu đặc biệt: Nothing. 
+			Kiểu dữ liệu này không có giá trị và thường được dùng để đánh dấu các vị trí trong code mà code không bao giờ có thể chạy tới được. 
+			Với code của bạn, bạn có thể sử dụng Nothing để xác định các function mà không bao giờ trả về giá trị gì:
+			+ fun fail(message: String): Nothing { throw IllegalArgumentException(message) }
+		
+		- Khi bạn gọi function này, compiler sẽ biết rằng việc thực thi không thể tiếp tục sau khi function này được gọi:
+			val s = person.name ?: fail("Name required")
+			println("hello") // code không thể chạy tới dòng này
+		
+
+1.8. Funtcion
+	- syntax: fun methodName(var1: <dataType>, var2: <dataType>): <return_dataType> { // method body }
+	- Single-Expression functions: fun sumOf(a: Int, b: Int) = a + b
+	- Inline function
+	- Funtion types:
+		+ Standard Library Funtions
+		+ User defined Functions
+
+	- Function References: ::funtionName -> có thể dùng với các method overload
+	
+	- Function Scope: Modifiers
+		+ Member function: 	Là các function được khai báo ở trong class, object hoặc interface -> call: instance.funtion()
+		
+		+ Local function:	nested function -> không sử dụng đc ngoài funtion cha, chỉ sử dụng đc các param và biến khai báo trước nó trong function cha, khai báo sau thì không thể sử dụng.
+			fun printArea(width: Int, height: Int): Unit {		// local function: calculateArea
+				fun calculateArea(width: Int, height: Int): Int = width * height
+				val area = calculateArea(width, height)
+				println("The area is $area")
+			}
+			
+		+ Top-level function: Có thể hiểu rằng đây là những function được khai báo ngoài tất cả như class, object, interface, method và được định nghĩa trong file Kotlin (.kt). 
+			Các method được truy cập thông qua tên của file vs kí hiệu "kt" (đối với Java), trong Kotlin các function này được gọi trực tiếp qua tên của function. 
+			Việc này rất hữu ích trong việc định nghĩa các các function hepler, util mà trong Java hay làm thông qua các method static.
+			
+
+	- Tham số mặc định: fun demo(num: Int = 10, ch: Char = 'A') -> demo();		demo(num=20);		demo(ch='Z')
+		+ Điều này giúp không phải viết quá nhiều overload function.
+		+ Khi kế thừa, class cha có param mặc định thì class con khi override method không đc định nghĩa lại giá trị mặc định đó
+		+ Khi gọi hàm, nếu có param nào miss thì các param khác pass vào theo kiểu: param=value
+		
+		+ Khi sử dụng function của Kotlin trong Java, các param được khai báo giá trị mặc định sẽ không có tác dụng. Vì Java không thể bỏ qua các param có giá trị mặc định.
+		+ Khi sử dụng function của Java trong Kotlin, không thể sử dụng được chức năng đặt tên cho đối truyền vào.
+
+
+	- Đệ quy đuôi: tailrec
+		+ Việc tính toán được thực hiện ngay từ đầu trước khi gọi đệ quy. Lệnh gọi hàm đệ quy xảy ra ở cuối hàm. 
+			Điều đó có nghĩa là việc tính toán được thực hiện trước và sau đó được chuyển sang lệnh gọi đệ quy tiếp theo.
+
+	
+	- Lambda function: 
+		
+		+ Assign to variable: 				val sum = {num1: Int, num2: Int -> num1 + num2}
+		
+		+ Pass to funtion as parameter: 	numbers.filter { x -> x > 0 } 						// or map(x -> x > 0)
+		
+		+ Return lambda from function:		
+			- Function types: (Parameter_1, Parameter_2, ...) -> Return_Type: 
+				+ Ex: val upperCaseString: (String) -> String = { string -> string.uppercase() }  -> call:  upperCaseString("hello")
+		
+		+ invoke on its own: println( { string: String -> string.uppercase() }("hello") )
+		
+		+ Trailing lambdas: param cuối là 1 lambda -> tách riêng ra đc
+			- println(listOf(1, 2, 3).fold(0, { x, item -> x + item })) // 6
+			- println(listOf(1, 2, 3).fold(0) { x, item -> x + item })  // 6
+			
+	- Unit-returning functions: same Void in Java
+		+ 
+		
+	- Extension functions:
+		+ Giống với Swift, Kotlin cho phép ta mở rộng class mà không phải kế thừa từ class khác.
+		+ fun <T> MutableList<T>.swap(index1: Int, index2: Int) { } --> using: list.swap(0, 2)
+	
+	- Mutiple return values:
+		+ Using data class with primary constructor:
+		+ Destructuring Declarations:
+			data class Person(var name: String, var age: Int)		==== complie:			data class Person(var name: String, var age: Int)
+			val (name, age) = Person("Hado", 22)											val person = Person("Hado", 22)
+																							val name = person.component1()
+																							val age = person.component2()
+																							
+			- Lưu ý chỉ có các param trong primary constructor mới được tự động tạo ra function component. 
+			- Nếu chúng ta khai báo thêm biến trong class và muốn sử dụng Destructure thì cần khởi tạo thêm các function component tương ứng với param đó:
+				+ data class Person(var name: String, var age: Int) {
+					var province: String = "Ha Noi"
+
+					operator fun component3(): String {
+						return province
+					}
+				}
+		
+			+ val (_, age, province) = Person("Hado", 22) // ko lay gia tri name
+	
+	
+	- Generic functions:
+		+ fun <T> singletonList(item: T): List<T> {}
+		+ fun <T> T.basicToString() : String {}				// extension function
+		+ fun <T : Comparable<T>> sort(list: List<T>) {}	// class T kế thừa Comparable
+		
+		+ ussing:	val l = singletonList<Int>(1)
+		
+		
+	- Infix notation: Function có thể sử dụng infix notation (trung tố) khi
+		+ Function là member của một class hoặc là extension của class
+		+ Function chỉ có một param duy nhất
+		+ Function được mark bằng infix ở đầu function
+		
+		+ class Fly(var currentPlace: String) {
+			infix fun flyTo(nextPlace: String) {
+				println("The plane fly from $currentPlace to $nextPlace")
+			}
+		}
+
+		val plane1 = Fly("Ha Noi")
+		plane1 flyTo "Ho Chi Minh" //print: The plane fly from Ha Noi to Ho Chi Minh
+		plane1.flyTo("Ho Chi Minh") //print: The plane fly from Ha Noi to Ho Chi Minh
+			
+	- Function với parameter không xác định: 	fun add(vararg array: Int) : Int {}  --> add(1, 2, 3)
+		+ Ta sử dụng từ khóa vararg. Và cũng tương tự như Java, biến array được coi là một mảng.
+			Lưu ý: Chỉ có một param được đánh dấu là vararg. Nếu param không phải là param cuối cùng, khi gọi hàm, ta phải chỉ định rõ các param sau đó.
+		
+	///////////////////////////////////////////////////////////////////////////////
+	// Viblo
+	- High-Order Function: function has parameter that is another function or return another function
+		+ fun doSomethingWithNumber(number: Int, receiver: (String?) -> Unit) {//do somthing} 		// receiver = fun(string: String?) {} -> call: doSomethingWithNumber(1000, ::processWithResult)
+			- "::": toán tử Function References, có thể sử dụng với các overload function
+		
+		+ loại function này bộc lộ một số hạn chế lúc runtime: mỗi function là một object và nó giữ closure của nó.
+			Bởi vậy, việc cấp phát bộ nhớ (cho cả function object, class) và các lời gọi ảo cho ra một chi phí lúc runtime. 
+			Tức là khi gọi các function này, một object sẽ được tạo ra để lưu trữ function và thêm vài function cần thiết cho class nữa. 
+			Việc này làm cho số function của project sẽ tăng lên nhanh chóng.
+
+		+ Function Anonymous: doSomethingWithNumber(1000, fun (result: String?) {} )
+
+	- Lambda return:
+		
+		+ listOf(1, 2, 3).filter {
+			val shouldFilter = it > 0
+			shouldFilter						// way 1: return only for filter
+			//return@filter shouldFilter		// way 2: return only for filter
+			//return shouldFilter				// return for parent funtion
+		}
+
+	- Closures:
+		+ Lambda, anonymous function, local function và object expression đều có thể truy cập closure của nó (nôm na như là vùng bên ngoài khai báo nó). 
+			Nó có thể truy cập các function, biến và param được khởi tạo ở bên ngoài, (không giống Java, ta chỉ sử dụng được các biến và param ở vùng bên ngoài nếu như chúng được khai báo là final)
+		+ 
+
+
+	- Function Literals: A function literal is just an expression that defines an unnamed function.
+		+ val m = { (x : String) -> println("$x") }
+			val n : (String) -> Unit = { x -> println("$x") }
+			val o : (String) -> Unit = { (x : String) -> println("$x") }
+			
+	- Function Literals with Receiver: val sum = fun Int.(other: Int): Int = this + other
+		+ fun Int.sum(other: Int): Int {
+			return this + other
+		 }
+		 
+		+ Receiver object: 	nói đến đối tượng thực hiện extension --> fun Int.sum(other: Int): Int { return this + other }
+		
+	- Inline function:		code của function sẽ được thêm ngay ở nơi gọi function, tránh khởi tạo một instance để lưu function (solution for high-order function)
+		+ inline fun close(work: String, process: (String) -> Unit) {}		// process is func(str: String): Unit {}
+		+ Từ khóa inline sẽ có ảnh hưởng đến cả các lambda bên trong được truyền cho function. Nghĩa là tất cả các function bây giờ sẽ được inline ở nơi gọi.
+		+ Việc sử dụng inline function cũng có một số hạn chế. Đó là:
+			- Một inline function không thể tự gọi lại chính nó một cách trực tiếp hoặc gọi gián tiếp thông qua một inline function khác.
+			- Một public inline function được khai báo ở trong một class chỉ có thể truy cập vào các public function và public field của class đó
+			- Số lượng dòng code sẽ tăng lên. Việc inline một function dài, phức tạp nhiều lần sẽ được compiler sinh ra code tương ứng.
+			
+		+ noinline:
+			- inline có tác dụng với các lambda đc truyền vào function, lambda lúc đó cũng là inline func, để hủy bỏ dùng noinline trước lambda.
+		
+		+ Non-local return:
+			- return trong inline lambda gọi là non-local return, sau return thoát ra function ngoài (break vs continue ko đc hỗ trợ trong lambda)
+			- crossinline func: () -> Unit: 
+			
+		+ Reified type parameter: Xác định cụ thể kiểu param
+			- reified: param đã có thể truy cập bên trong function và không cần sử dụng reflection nữa, các toán tử như is, !is hay as cũng đã hoạt động bình thường
+			- Lưu ý: function không phải là inline function không thể sử dụng reified type parameter.
+			
+			- inline fun <reified T> membersOf() = T::class.members 		--> 	println(membersOf<StringBuilder>().joinToString("\n"))
+			- inline fun <reified T> TreeNode.findParentOfType(): T? {}		-->		treeNode.findParentOfType<MyTreeNode>()
+
+		+ Inline property:
+			- Từ khóa inline có thể được sử dụng với các hàm getter, setter của các property mà không có backing field: inline get() = Foo()		inline set(v) { ... }			inline var bar: Bar
+			- Ở vị trí gọi function, các hàm getter, setter này cũng sẽ được coi như các hàm inline function bình thường.
+		
+	///////////////////////////////////////////////////////////////////////////////
+
+
+1.9. OOP
+	- Object = attribute + method (thuộc tính + hành vi)
+
+	- Một số đặc điểm của OOP:
+		+ Tập trung vào dữ liệu thay cho các hàm.
+		+ Chương trình được chia thành các đối tượng độc lập.
+		+ Cấu trúc dữ liệu được thiết kế sao cho đặc tả được các đối tượng.
+		+ Dữ liệu được che giấu, bao bọc.
+		+ Các đối tượng trao đổi với nhau thông qua các hàm.
+		+ Chương trình được thiết kế theo hướng tiếp cận từ dưới lên (bottom-up): Phương
+			pháp xây dựng chương trình bottom-up là phương pháp thường dùng để xây dựng
+			phần mềm lớn, phức tạp. Ý tưởng của phương pháp này là xuất phát từ nhiều thành
+			phần nhỏ đã có sẵn, ta khéo kết hợp chúng lại để tạo ra thành phần chức năng lớn
+			hơn, ta tiếp tục kết hợp các thành phần xây dựng được để tạo ra thành phần lớn hơn
+			nữa… cho đến khi xây dựng được chương trình giải quyết được bài toán mong
+			muốn.
+			
+	- Một số ưu điểm nổi bật của OOP:
+		+ Không có nguy cơ dữ liệu bị thay đổi tự do trong chương trình.
+		+ Khi thay đổi cấu trúc dữ liệu của một đối tượng, không cần thay đổi mã nguồn của các đối tượng khác.
+		+ Có thể sử dụng lại mã nguồn, tiết kiệm tài nguyên.
+		+ Phù hợp với các dự án phần mềm lớn, phức tạp.
+		+ Khái niệm đối tượng (object) trong lập trình hướng đối tượng giống như một đối tượng cụ thể trong thế giới thực.
+		
+	- Mỗi đối tượng có các thuộc tính và các hành vi riêng:
+		+ Thuộc tính (attribute) mô tả đặc điểm của đối tượng.
+		+ Hành vi là phương thức hoạt động của đối tượng, gọi tắt là phương thức (method).
+
+	- Class: 
+		+ Các đối tượng có các đặc điểm (thuộc tính và phương thức) giống nhau được gom nhóm
+			thành một lớp để phân biệt với các đối tượng khác và dễ quản lý.
+		+ Một lớp (class) là sự phân loại của các đối tượng hay là kiểu (type) của đối tượng.
+		+ Như vậy Lớp(Class) là một khái niệm trừu tượng, dùng để chỉ một tập hợp các đối
+			tượng có mặt trong hệ thống
+		
+	- Gói (package)
+		+ Một nhóm các lớp (classes) và giao diện (interfaces) được tổ chức thành một đơn vị
+			quản lý theo hình thức không gian tên gọi là package.
+		+ Lợi ích của package là tổ chức sắp xếp lại hệ thống thông tin các lớp trong dự án một
+			cách khoa học, giúp cho việc theo dõi bảo trì dự án được tốt nhất.
+			
+	- 1. Abstraction: Tính trừu tượng
+		+ TH1: Lớp (Class) là một khái niệm trừu tượng, đối tượng là một thể hiện cụ thể của lớp.
+		+ TH2: Từ những đối tượng giống nhau: trừu tượng hóa thành một lớp -> Chỉ đưa ra các thuộc
+			tính và phương thức cần thiết của đối tượng trong lập trình.
+
+	- 2. Encapsolution: Tính đóng gói
+		+ Mỗi lớp được xây dựng để thực hiện một nhóm chức năng đặc trưng của riêng lớp đó.
+		+ Tất cả mọi thao tác truy xuất vào thành phần dữ liệu từ đối tượng này qua đối tượng
+			khác phải được thực hiện bởi các phương thức (method) của chính đối tượng chứa dữ liệu.
+		+ Tính đóng gói cho phép dấu thông tin của đối tượng bằng cách kết hợp thông tin và
+			các phương thức liên quan đến thông tin trong đối tượng.
+		
+	- 3. Inheritance: Tính kế thừa
+		+ Cho phép xây dựng một lớp mới dựa trên các định nghĩa của một lớp đã có.
+		+ Lớp đã có gọi là lớp Cha, lớp mới phát sinh gọi là lớp Con
+		+ Lớp con kế thừa tất cả các thành phần của lớp Cha, có thể mở rộng các thành phần kế thừa và bổ sung thêm các thành phần mới.
+		
+		+ Tổng quát hoá: Những đặc điểm chung mà các lớp đều có ==> là các lớp Cha
+		+ Chuyên biệt hóa: Những đặc điểm riêng chỉ có các lớp con mới có ==> là các lớp Con
+
+	- 4. Overloading: Đa hình
+		+ Là một đối tượng thuộc các lớp khác nhau có thể hiểu cùng một thông điệp theo cách khác nhau.
+			Ví dụ đa hình trong thực tế: Mình có 2 con vật: chó, mèo hai con vật này khi nhận được mệnh lệnh là
+			"hãy kêu" thì chó kêu "gâu gâu",  mèo kêu "meo meo".
+		+ Trong code để thể hiện tính đa hình có 2 cách:
+			- Method Overloading (compile time polymorphism): là cách nạp chồng các method có cùng tên nhưng khác tham số
+			- Method Overriding (run time polymorphism): Đây là một phương pháp được ghi đè lại các method ảo của một lớp cha
+		
+		+ Overloading: Là đặc điểm trong cùng 1 lớp có nhiều phương thức cùng tên nhưng khác nhau về Signature.
+		+ Signature bao gồm: Số lượng các đối số hoặc kiểu dữ liệu các đối số hoặc thứ tự các đối số.
+		+ Kiểu dữ liệu trả về không được tính vào signature
+		+ Lợi ích của Overloading là khả năng tái sử dụng lại phương thức và giúp việc gọi hàm “uyển chuyển”.
+		+ Các Constructor là trường hợp đặc biệt của Overloading Method.
+
+
+1.10. Class
+
+	- Define:
+		+ class MyClass {}		
+		+ Empty class: class Empty
+		+ class ClassName: 
+		+ final / open:	 -> default is final
+		+ public/private class: default is public
+
+	- Constructor:
+		+ default: kolin create 1 public primary constructor with no params
+		+ 1 primary constructor + n secondary constructors
+		+ primary constructor:			not contains any code -> use init{} to create default value for primary constructor
+			- class SinhVien constructor(ma: Int, ten: String){}  // ignore constructor if primary constructor has no visibility modifier or annotations
+			- class SinhVien (ma: Int, ten: String){}
+			- class SinhVien (ma: Int, ten: String){
+				init {
+					println("Mã=$ma ; Tên =$ten")
+				}
+			}
+			- Used: var lanh = SinhVien(113, "Trần Thị Long Lanh") --> not need new Object()
+		+ secondary constructors: if there is a primary constructor, secondary constructor must call to primary constructor directly or nondirectly
+			- constructor() {}
+			- constructor(ma: Int, ten: String) {}
+			- class SinhVien (ma: Int, ten: String){
+				constructor() {}
+				constructor(ma: Int, ten: String) {}
+			}
+
+	- Visibility modifier = Access modifier: public, internal, protected, private, áp dụng cho class, object, interface, constructor, function, property(và function set() của nó) // function get() của property luôn có visibility modifier giống với property
+		+ Nếu không xác định rõ ràng visibility modifier thì mặc định sẽ là public
+		
+		+ Package: Function, property, class, object và interface đều có thể khai báo ở mức "top-level" (được hiểu là nó không ở bên trong bất cứ thành phần nào), như trong package 
+			- private: 		chỉ được sử dụng ở file mà nó khai báo
+			- protected:	không được sử dụng khi khai báo ở mức "top-level"
+			- internal:		chỉ được sử dụng ở các nơi cùng module (cùng package)
+			- public: 		có thể sử dụng nó ở bất kì đâu
+			- default: 		public
+		
+		+ Class / Interface
+			- private:		chỉ được sử dụng trong class đó (không thể truy cập qua instance của class đó)
+			- protected:	giống với private + có thể sử dụng ở trong các subclass (các class kế thừa nó).
+			- internal: 	được truy cập bởi các instance của class khác khai báo nó (các instance và nơi khai báo class thuộc cùng module)
+			- public: 		được sử dụng ở bất kì đâu thông qua instance khai báo nó.
+			- default:		public
+		
+		+ Constructor:		class C private constructor(a: Int) { ... }
+			- default: 		public
+			
+		+ Module:
+			- internal:
+		
+		+ Local:
+			- Local variables, functions và class không có visibility modifier
+		
+
+	- Getter / Setter: define for each attribute
+		+ private var ma:Int=0
+		+ public var Ma:Int 
+			get() { return ma }
+			set(value) { ma = value }
+		+ Used: 
+			- in package: 	object.ma = 10;
+			- out package: 	object.Ma = 100		/ 	print(object.Ma)
+			
+		+ Từ Kotlin 1.1, bạn có thể bỏ qua kiểu dữ liệu của property nếu nó có thể được suy ra từ kiểu trả về của hàm getter:
+			- val isEmpty get() = this.size == 0  // isEmpty sẽ có kiểu là Boolean
+
+	- Method:
+		+ fun methodName(): <dataType> {}
+		+ override fun methodName(): <dataType> {}
+		+ types:
+			- Service method: like public method
+			- Support method: private method, support Service method
+			
+	- Reference This:
+		+ Instance variable: like attribute of class, all methods of class can use them.
+		+ Local variable: like parameter of method, read only, only method themself can use them
+		+ Nếu tại một dòng lệnh mà đồng thời cùng truy xuất tới instance variable và local variable(cùng tên) thì chương trình sẽ ưu tiên truy suất tới biến local variable
+			-> this dùng để phân biệt 2 loại biến có cùng tên
+			
+	- Overloading:
+		+ Same Java
+		+ Special: vararg = Parameter list
+			- fun printNumbers(vararg numbers: Int) {
+					for (number in numbers) {
+						println(number)
+					}
+			}
+
+	- Data Class: 	provider method: equals() / hashCode(), toString(), componentN(), copy()
+		+ data class User(var UserName: String, var Password: String)  -> var user1 = User(UserName = "obama", Password = "113@114Xa")
+
+	- Nested Class:
+		+ các lớp Nested sẽ không thể truy suất được các biến thành viên trong Outer class
+		+ class Outer {
+				private val bar: Int = 1
+				class Nested {
+					fun foo() = 113
+				}
+			}
+		+ Used: val demo = Outer.Nested().foo()
+		
+	- Inner Classes: các lớp Inner sẽ có thể truy suất được các biến thành viên trong Outer class
+		+ class Outer {
+				private val bar: Int = 1
+				inner class Inner {
+					fun foo() = bar
+				}
+			}
+		+ Used: val demo = Outer().Inner().foo()  -> this@Outer.bar = 5\
+		
+	- Anonymous inner class: using object key =  object expression
+		+ textView?.setOnClickListener(object : View.OnClickListener {}
+		+ Nếu object được khởi tạo là một functional Java interface (một interface chỉ có duy nhất một method), chúng ta có thể sử dụng lambda và khai báo như sau: val listener = View.OnClickListener {}
+		
+	- Enum Classes: Enum cũng là một loại Lớp đặc biệt trong Kotlin (giống như các ngôn ngữ khác C#, java…)
+		+ enum class XepLoai { XuatSac, Gioi, Kha, TrungBinh, Yeu, Kem }
+		+ Used: XepLoai.XuatSac, ...
+		
+	- Inheritance - Kế thừa: 			add open to can be Inheritance
+		+ every class is extended by Any: equals(), hashCode(), toString()
+		+ format: class AName : BName() {}
+		+ Overriding: need open method, final method can't override
+		
+		+ Đa kế thừa:
+			- class C() : A(), B() {
+				// The compiler requires f() to be overridden:
+				override fun f() {
+					super<A>.f() // call to A.f()
+					super<B>.f() // call to B.f()
+				}
+			}
+			
+	- Abstract Classes: 				extend cần override function
+		+ abstract class Base {
+				abstract fun calculate()
+			}
+			
+		+ open fun f(): none-abstract -> override abstract fun f(): abstract
+		
+	- Property và field: 				if not define get/set -> use get/set default method of kotlin, like that below:
+		+ private var num: Int = 0
+			fun get() { return num }
+			fun set(value) { num = number }
+			
+		+ val: (= constant) -> can not define set method
+		+ modifier of getter: same modifier of property, can not change it.
+		+ modifier of setter: <= modifier of property, can change it without implement setter method: private set //
+		+ call property by class.name, it's not directly call to name, it means call to get/set method -> ko call property trong các hàm get/set tự define vì gây ra StackOverflowError
+		+ field chỉ đc sử dụng bên trong các hàm get/set
+		
+		+ Backing field & Backing property:
+			- Backing field: call class.name, sử dụng name variable -> gọi setter / getter default
+			- Backing property: config setter / getter
+		
+	- Compile-time constant: 			const val SUBSYSTEM_DEPRECATED: String = "This subsystem is deprecated"
+		+ const -> (top-level property || member of a object) && primity data (String, Num, Boolean) && only default getter
+		+ object trong Kotlin là một singleton, không phải là đối tượng
+		
+	- Late-initialized property :		lateinit var className: String
+		+ property non-null: must initialize by directly or constructor
+		+ lateinit condition:
+			- only use with var property && only default get/set
+			- Data type: can not primity Data and must non-null
+			- UninitializedPropertyAccessException will raise if access property when it's not initialized
+		
+		+ lateinit: không làm việc với các kiểu dữ liệu nguyên thủy như Int -> using delegates: private var mNumber: Int by Delegates.notNull<Int>()
+		
+	- Overriding property:
+		+ use override: override val x: Int = 10
+		+ only override val property to var property + define setter
+		+ Từ khóa override cũng có thể sử dụng ngay trong primary constructor:
+			
+	
+1.11. Extension Method:
+	+ cho phép ta mở rộng class mà không phải kế thừa từ class khác
+-
+- 
+
+
+1.12. Null safety
+	+ Not null: 	var neverNull: String = "This can't be null"
+	+ Nullable:		var nullable: String? = "You can keep a null here"
+	+ var is not null can't set null: throw a compiler error
+	+ Method with not null param can't accept null param
+	
+	+ Check null: Use safe calls for properties and method
+		- fun lengthString(maybeString: String?): Int? = maybeString?.length
+		- Safe calls can be chained: person.company?.address?.country
+		
+	+ Use Elvis operator: use '?:' to return default value when null value is detected
+		- println(nullString?.length ?: 0)
+		
+	+ null?.apply / let {}
+		
+
+1.13. Modifiers order﻿: If a declaration has multiple modifiers, always put them in the following order:
+
+	public / protected / private / internal
+	expect / actual
+	final / open / abstract / sealed / const
+	external
+	override
+	lateinit
+	tailrec
+	vararg
+	suspend
+	inner
+	enum / annotation / fun // as a modifier in `fun interface`
+	companion
+	inline / value
+	infix
+	operator
+	data
+
+
+1.14. This
+	+ Class: this = instance class
+	+ extension function / function literal with receiver: this biểu thị param của function - tức là giá trị được truyền vào bên trái dấu . 
+		Nếu this không có label chỉ định đối tượng chỉ vào, this tham chiếu tới phạm vi chứa gần nhất. 
+		Để tham chiếu đến một phạm vi khác, label chỉ định sẽ được sử dụng
+	
+	+ Label chỉ định: this@labelName
+	
+
+1.15. Interface
+	+ abstract function:
+	+ function with body:
+	+ property: 
+		- không được khởi tạo cho property trong interface, và interface không có backing fields
+	
+	+ Kế thừa Interface: class Child : MyInterface { override fun bar() {} } // override property: same
+	+ Đa kế thừa: dùng super<A>.function(), super<B>.function()
+
+	
+1.16. Data class:
+	+ data class User(val name: String, val age: Int)
+	+ equals(), hashCode(), toString() dưới dạng User(name=John, age=42)
+	+ componentN(): user.component1()
+	+ copy(): 
+		- cần copy một đối tượng nhưng lại muốn thay đổi một số property và giữ nguyên phần còn lại: val jack = User(name = "Jack", age = 1)  --> val olderJack = jack.copy(age = 2)
+	
+	+ Để đạt được tính nhất quán và các hành vi có ý nghĩa của code được sinh ra, data class phải thỏa mãn những yêu cầu sau:
+		- Primary constructor phải có ít nhất 1 param
+		- Tất cả param của primary constructor phải được khai báo là var hoặc val
+		- Data class không thể là abstract, open, sealed hay inner class.
+		- Data class chỉ có thể implement các interface (Trước phiên bản 1.1)
+	+  Nếu tất cả các param của primary constructor có giá trị mặc định, compiler sẽ tự sinh ra thêm một constructor không có tham số sử dụng các giá trị mặc định đã khai báo ở primary constructor	
+	
+	+ Destructuring Declaration:
+		- val jane = User("Jane", 35) -> val (name, age) = jane 	// Với các hàm componentN() được tự sinh ra
+
+1.17. Kotlin Lambda
+	+ Biểu thức của lambda luôn được bao bởi {}
+	+ Nếu lambda function có bất kì param nào nó phải ở trước toán tử -> (kiểu dữ liệu của param có thể được bỏ qua)
+	+ Body của lambda function phải ở sau toán tử ->
+	
+	+ Implicit name of a single parameter: doSomethingWithNumber(1000) { println("The result is $it") // do something with result } // Có thể hiểu ở đây it là tên đại diện cho parameter duy nhất
+	+ Destructuring trong Lambdas:
+		- map.mapValues { entry -> "${entry.value}!" }
+		- map.mapValues { (key, value) -> "$value!" }
+		
+	+ Lambda return:
+		- ints.filter {
+				val shouldFilter = it > 0
+				shouldFilter == return@filter shouldFilter
+			}
+	+ Closures:
+		- Lambda, anonymous function, local function và object expression đều có thể truy cập closure của nó (nôm na như là vùng bên ngoài khai báo nó). 
+			Nó có thể truy cập các function, biến và param được khởi tạo ở bên ngoài, ko cần final như java
+		- 
+	
+	+ Function Literals:		A function literal is just an expression that defines an unnamed function.
+		- function = biểu thức:
+		
+		- Function Literals với receiver:
+			+ Receiver object: receiver object nói đến đối tượng thực hiện extension, 		fun Person.run() {} -> class Person được coi là receiver object 	// like: fun Int.sum(other: Int): Int { return this + other }
+			+ val sum = fun Int.(other: Int): Int = this + other	--> 
+	
+	+ Inline function: above
+		
+
+1.18. Kotlin Collection
+	+ Kotlin cung cấp cho chúng ta một tập các native interface để làm việc với collection::
+		- Iterable: 			Lớp cha. Bất kỳ class nào kế thừa từ interface này đại diện cho một chuỗi các phần tử mà chúng ta có thể duyệt qua
+		- MutableIterable: 		Iterable hỗ trợ việc xóa các phần tử trong khi đanh duyệt
+		- Collection:			immutable -> size(), empty()
+		- MutableCollection: 	Collection hỗ trợ việc thêm hoặc xóa các phần tử: các hàm add, remove, clear...
+		- List/MutableList:
+		- Set/MutableSet:		một tập các phần tử không có thứ tự và không hỗ trợ lưu các phần tử trùng
+		- Map/MutableMap:		key - value -> val readWriteMap = hashMapOf("foo" to 1, "bar" to 2) 		//// 		val snapshot: Map<String, Int> = HashMap(readWriteMap)
+		
+	+ Methods:
+		- .any, .all, .none: 	return true if any/all/none element meet codition
+		- .count:				return number of element which meet codition
+		- .fold/foldRight:		Tổng của các giá trị bắt đầu từ giá trị khởi tạo và áp dụng việc tính toán ở hàm được đưa vào với các phần tử từ đầu đến cuối collection. list.fold(init_calue, {sum: Int, i: Int -> sum + i})
+		- .reduce/reduceRight:	tương tự fold nhưng không có có giá trị khởi tạo
+		- .forEach:				it		.forEachIndexed	{ idx: Int, value: Any -> .... }
+		- .max/.min:	
+		- .sumBy(condition):	.sumBy{it % 3}
+		- .drop/.dropWhile():	return list bao gồm tất cả các phần tử trừ n phần tử đầu tiên
+		- .dropWhile/.dropWhileLast:	Trả về một list bao gồm tất cả các phần tử trừ các phần tử đầu tiên mà thỏa mãn logic truyền vào /  tuy nhiên sẽ loại các phần tử cuối nếu thỏa mãn logic truyền vào
+		- .filter/.filterNot/.filterNotNull:
+		- .slice:
+		- .take/.takeLast/:		Trả về một list gồm n phần tử đầu tiên
+		
+		- .flatMap{ logic(it) }: 	Trả về một list bao gồm tất cả các phần tử của các logic
+		- .groupBy{ logic(it) }:	Trả về một map bằng cách áp dụng logic truyền vào và phân loại các phần tử trong collection thành các nhóm
+		- .map{ logic(it) }:		Trả về một list là kết quả của logic chuyển đổi được truyền vào áp dụng với tất cả các phần tử của collection ban đầu
+		- .mapIndexed{idx, value -> logic}:	Trả về một list là kết quả của logic chuyển đổi được truyền vào áp dụng với tất cả các phần tử và idx của collection ban đầu
+		- 
+		
+	+ Khởi tạo:
+		- list = listOf(items) / mutableListOf(items); // immutable
+		- map = mapOf(a to b, c to d)
+		
+	+ Generic:
+		- .partition{ logic(it) }﻿:	return Pair (collection(logic), collection(not logic)
+		- .plus:					list1.plus(list2) = list1 + list2
+		- .zip:						list1.zip(list2) = listOf[(i1, j1), (i2, j2), ..., (in, jn)], n = min(len(list1), len(list2))
+		- 
+	+ Order:
+		- .reverse/.sorted/.sortedBy/.
+		
+
+1.19. Enum class:
+	+ enum class Protocol(val num: Int, val str: String) {
+		WAITING(1, "WAITING_") { // a Anonymous Classes
+			override fun signal() = TALKING
+			override fun self() = str
+		},
+		TALKING(2, "TALKING_") {
+			override fun signal() = WAITING
+			override fun self() = str
+		};
+		abstract fun signal(): Protocol
+		abstract fun self(): String
+	}
+	
+	+ Mỗi enum constant đều có 2 propery:
+		- val name: String			// name of enum
+		- val ordinal: Int			// order of enum in list
+		
+	+ Từ Kotlin 1.1 trở đi, ta có thể truy cập vào các constant trong enum class bằng generic way: enumValues<T>() và enumValueOf<T>()
+		inline fun <reified T : Enum<T>> printEnumAllValues() {
+			val arr: Array<T> = enumValues<T>()
+			println("enumValues: " + arr.joinToString { it.name + " - " + it.ordinal })
+		}
+
+		inline fun <reified T : Enum<T>> printEnumValueOf(name: String) {
+			val element: T = enumValueOf<T>(name)
+			println("enumValueOf: " + element.name + " - " + element.ordinal)
+		}
+
+1.20. Overloading operator:
+
+	+ operator fun plus() {}
+
+	+ 1 ngôi:
+		+a = a.unaryPlus()			-a = a.unaryMinus()			!a = a.not()			a++ = a.inc()				a-- = a.dec()
+		
+	+ 2 ngôi:
+		a + b = a.plus(b)			a - b = a.minus(b)			a * b = a.times(b)		a / b = a.div(b)			a % b = a.rem(b)		a..b = a.rangeTo(b)
+	
+	+ in:
+		a in b = b.contains(a)		a !in b = !b.contains(a)
+		
+	+ index: [] -> get/set
+		a[i] = a.get(i)				a[i, j] = a.get(i, j)		a[i] = b === a.set(i, b)			a[i, j] = b === a.set(i, j, b)
+		
+	+ operator call:
+		a() = a.invoke()			a(i) = a.invoke(i)			a(i, j) = a.invoke(i, j)			a(i_1, ..., i_n) = a.invoke(i_1, ..., i_n)
+		
+	+ Toán tử tăng và gán﻿: nếu đã dùng plusAssign() thì ko dùng plus() nữa
+		a += b === a.plus/minus/times/div/mod/Assign(b)
+
+	+ Toán tử so sánh: a.compareTo(b)
+		
+
+
+1.21. Kotlin range: (IntRange , LongRange , CharRange) 	=== 	.rangeTo()	===		.downTo() 	===		i in 1..10
+	+ 1..10 step 3			4 downTo 1 step 2			1 until 10
+	+ 
+	
+
+1.23. Kotlin delegated: 	Delegates.kt
+	
+	+ Class Delegation
+		- class Derived(b: Base) : Base by b		:		Lớp Derived có thể kế thừa từ interface(chỉ có thể sử dụng delegation với interface) Base và ủy thác tất cả các public method cho một đối tượng xác định. 
+			Tức là, lớp Derived tuy kế thừa từ interface Base nhưng không phải implement function print() từ interface Base mà ủy thác cho đối tượng b có kiểu là BaseImpl, lớp cũng kế thừa từ Base và implement function print().
+	
+	+ Delegated property:	val/var <property name>: <Type> by <expression>		-->		var p: String by DelegateString()
+		- lazy property: Giá trị của property được tính toán trong lúc truy cập lần đầu tiên đến property
+		- observable property: lắng nghe sự thay đổi giá trị của property
+		- Lưu trữ các property trong một map thay vì lưu riêng từng property
+		
+		- Biểu thức ở sau by là delegate, bởi vì get()/set() tương ứng với property sẽ được ủy thác cho các method getValue()/setValue() của class Delegate. 
+			Delegate không cần phải implement bất kỳ interface nào nhưng phải cung cấp 2 function là getValue() (và setValue() đối với property kiểu var)
+			
+			class Delegate {
+				operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
+					System.out.println("first")
+					return "$thisRef, thank you for delegating '${property.name}' to me!"
+				}
+
+				operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
+					println("$value has been assigned to '${property.name} in $thisRef.'")
+				}
+			}
+		
+		- lazy: là một function lấy một lambda và trả về một instance của Lazy<T> để có thể implement một lazy property: lần gọi đầu tiên đến function get() sẽ thực thi đoạn code trong lambda được truyền vào 
+			để khởi tạo kết quả và gán kết quả cho property. Các lần gọi get() sau sẽ chỉ trả về giá trị của property.
+			Mặc định, việc tính toán của lazy property được synchronized: giá trị được tính toán chỉ trong 1 thread, và tất cả các thread sẽ sử dụng cùng kết quả đó.
+			+ LazyThreadSafetyMode.NONE / LazyThreadSafetyMode.PUBLICATION: tính toán value trong 1 thread hoặc multi thread. (truyền tham số LazyThreadSafetyMode.PUBLICATION cho function lazy())
+		
+		- observable: Delegates.observable() nhận vào 2 tham số: giá trị khởi tạo của property và một handler trong trường hợp property thay đổi giá trị. 
+			Handler mà chúng ta truyền vào sẽ được thực thi mỗi lần chúng ta gán giá trị cho property (sau khi việc gán được thực thi). Handler này có 3 tham số: property được gán, giá trị cũ và giá trị mới.
+			+ var name: String by Delegates.observable("<no name>") { prop, old, new -> println("$old -> $new") }
+			
+			+ vetoable(): Hanlder được truyền vào vetoable sẽ được gọi trước khi việc gán được thực thi -> có thể can thiệp vào việc gán và phủ quyết việc đó.
+			
+		- Lưu trữ property trong một map:
+			+ class User(val map: Map<String, Any?>) {
+				  val name: String by map
+				  val age: Int     by map
+				}
+
+				val user = User(mapOf(
+				  "name" to "John Doe",
+				  "age"  to 25
+				))
+						
+		
+		- Local delegated property: 	Bạn có thể khai báo một local variable như là một delegated property
+			+ fun example(computeFoo: () -> Foo) {		// computeFoo: lambda, Biến memoizedFoo sẽ chỉ được tính toán vào lần truy cập đầu tiên bằng lambda computeFoo được truyền vào
+				val memoizedFoo by lazy(computeFoo)		// Nếu someCondition bằng false, memoizedFoo sẽ không được khởi tạo.
+
+				if (someCondition && memoizedFoo.isValid()) {
+					memoizedFoo.doSomething()
+				}
+			}
+	
+	
+1.xx. Kotlin idioms
+		
+	+ POJO object: 				data class
+	+ Parameter default: 
+	+ String template: 			println("Name $name")
+	+ Ép kiểu:					as?		trả về null nếu ép kiểu thất bại
+	+ Kiểm tra kiểu: 			when (x) { 
+									is Type1 -> ...
+									is Type2 -> ...
+									else	 -> ...
+								}
+	
+	+ Khởi tạo lazy:			val p: String by lazy {"ex"}	giá trị lazy sẽ ko đc khởi tạo trước khi biến được sử dụng lần đầu, ko bắn exception, sử dụng đc với cả biến "val & var"
+	+ lateinit: 				cam kết khẳng định biến sẽ được khởi tạo trước khi sử dụng, nếu truy cập trước khi khởi tạo thì bắn exception UninitializedPropertyAccessException, chỉ sử dụng đc với biến "var"
+	+ Null safety:				file?.size()
+		- Theo mặc định, tất cả các biến, thuộc tính của Object đều là non-null (không thể giữ giá trị null)  – Trừ khi chúng được khai báo là nullable:	var number: Int? = null
+		- 
+		- 
+		
+	+ by
+	+ with(): 	rất hữu ích khi bạn cần truy xuất vào nhiều thuộc tính của cùng một đối tượng. Nó giúp bạn đỡ phải gõ nhiều tên đối tượng để gọi thuộc tính
+	
+	+ Extension function: 		fun String.spaceToCamelCase() { ... }		->		"Convert this to camelcase".spaceToCamelCase()
+	+ Tạo một singleton:		
+	+ Single-expression functions:	
+	+ Gọi nhiều method trên cùng một instance object﻿: with(params) { param.method1()	param.method2()		param.method3() }
+	+ companion object: ~ static object -> companion object Test { fun callMe() = println("I'm called.") }
+		- Các đối tượng companion có thể truy cập các thành viên riêng tư của class. Do đó, chúng có thể được sử dụng để thực hiện factory phương thức patterns
+	+ .let/ .apply
+	
+	// Layout
+	+ Static Layout Import: view_id.event()		// Fragment: setContentView() trong onCreateView(), dùng UI trong onViewCreated()
+	
+	+ Exception: chỉ duy nhất các lỗi sau đây mới gây ra NullPointerException
+		- user throw NullPointerException
+		- toán tử: !!		-> sử dụng khi muốn throw NullPointerException để test như java		:		val number: Int? = null; number!!.toString()
+		- lateinit: truy xuất trước khi khởi tạo -> UninitializedPropertyAccessException
+		- 
+		
+	+ Chuyển một Object sang Map:
+		- 
+	 
+  	
+2.xx. Keys of Kotlin
+	+ by:
+	+ reified:		https://viblo.asia/p/tu-khoa-reified-trong-kotlin-loi-hai-ra-sao-4P856kOAKY3
+	+ lateinit:
+	+ object: khai báo class Singleton, mọi field bên trong ddeuf là static
+	+ companion object: gom các class static member vào 1 chỗ
+	+ const: khai báo các hằng số với kiểu dữ liệu nguyên thuỷ
+	+
+	+ 
+	+
+	+ 
+	+
+	+ 
+	+
+	+ 
+	+
+	+ 
+	+
+	+ 
+	+
+	+ 
+	+
+	+ 
+	+
+	+ 	
+
+# https://kotlinlang.org/docs/kotlin-tour-control-flow.html#when
+# https://buihainam.com/kotlin/kotlin_property_field/
+
+
+![alt text](https://developer.android.com/topic/libraries/architecture/images/final-architecture.png)
+
+
+API https://www.themoviedb.org/documentation/api
+
+Kotlin: https://kotlinlang.org/docs/reference/
+
+Data binding: https://developer.android.com/topic/libraries/data-binding/
+
+RxJava 2, RxAndroid: https://github.com/ReactiveX/RxJava
+
+Coroutines: https://kotlinlang.org/docs/reference/coroutines.html
+
+Retrofit 2: https://github.com/square/retrofit
+
+Moshi: https://github.com/square/moshi
+
+Glide: https://github.com/bumptech/glide
+
+Dagger-Hilt: https://developer.android.com/training/dependency-injection/hilt-android
+
+Android X: https://developer.android.com/topic/libraries/support-library/androidx-overview
+
+
+===> Android Architecture Component
+
+Lifecycle: https://developer.android.com/topic/libraries/architecture/lifecycle
+
+View Model: https://developer.android.com/topic/libraries/architecture/viewmodel
+
+Live data: https://developer.android.com/topic/libraries/architecture/livedata.html
+
+Room: https://developer.android.com/topic/libraries/architecture/room.html
+
+Navigation: https://developer.android.com/guide/navigation
+
+Architecture: https://github.com/googlesamples/android-architecture-components
+
+<===
+
+https://developer.android.com/topic/modularization?hl=en
+
+https://developer.android.com/build/build-variants#dependencies
+
+
+https://developer.android.com/training/
+https://developer.android.com/build/
+https://developer.android.com/topic/
+https://developer.android.com/guide/
+
+https://fs-sournary.github.io/tags/Kotlin/
+
Index: app/src/main/assets/AndroidDoc/03.Basic_ListAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/AndroidDoc/03.Basic_ListAdapter.java b/app/src/main/assets/AndroidDoc/03.Basic_ListAdapter.java
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/AndroidDoc/03.Basic_ListAdapter.java	(date 1731353706000)
@@ -0,0 +1,1 @@
+// 3.ListAdapter.java
Index: app/src/main/assets/AndroidDoc/02.Basic_ViewLayout.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/AndroidDoc/02.Basic_ViewLayout.java b/app/src/main/assets/AndroidDoc/02.Basic_ViewLayout.java
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/AndroidDoc/02.Basic_ViewLayout.java	(date 1731353706000)
@@ -0,0 +1,1 @@
+// 2.ViewLayout.java
Index: app/src/main/assets/AndroidDoc/50.Java_Reflection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/AndroidDoc/50.Java_Reflection.java b/app/src/main/assets/AndroidDoc/50.Java_Reflection.java
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/AndroidDoc/50.Java_Reflection.java	(date 1731353706000)
@@ -0,0 +1,29 @@
+// 50.Reflection.java
+// java.lang.reflect
+
+@RequiresApi(api = 26)
+public void invokeMethod() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
+    Class classObj = Class.forName("com.example.androidtraining.Temp"); // way 1
+    classObj = classObj.getClass();     // way 2, from ready object
+    // invoke method
+    Method method = classObj.getMethod("methodName", String.class); // (methodName, parameters)
+    method.invoke(classObj, "arg");  // (classObj, parameters)
+
+    // other way
+    Constructor[] constructors = classObj.getConstructors();
+    Constructor constructor = constructors[0];
+    Parameter[] parameters = constructor.getParameters();
+
+    // methods
+    Method[] methods = classObj.getMethods();   // get public methods, removed duplicated methods
+    methods = classObj.getDeclaredMethods();    // get all methods
+
+    // parameters
+    Method method1 = methods[0];
+    Parameter[] parameters1 = method1.getParameters();
+    method1.getReturnType();
+
+    Class[] classes = classObj.getDeclaredClasses();
+    Annotation[] annotations = classObj.getAnnotations();
+    Field[] fields = classObj.getFields();
+}
Index: app/src/main/assets/AndroidDoc/100.AndroidBuild.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/AndroidDoc/100.AndroidBuild.java b/app/src/main/assets/AndroidDoc/100.AndroidBuild.java
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/AndroidDoc/100.AndroidBuild.java	(date 1731353706000)
@@ -0,0 +1,1 @@
+https://developer.android.com/build/build-variants#dependencies
Index: app/src/main/assets/AndroidDoc/06.Basic_Service.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/AndroidDoc/06.Basic_Service.java b/app/src/main/assets/AndroidDoc/06.Basic_Service.java
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/AndroidDoc/06.Basic_Service.java	(date 1731353706000)
@@ -0,0 +1,31 @@
+// 6.Service.java
+
+Here it goes,
+
+Its only a directional tag indicating which way the data goes.
+in - object is transferred from client to service only used for inputs
+out - object is transferred from client to service only used for outputs.
+inout - object is transferred from client to service used for both inputs and outputs.
+All non-primitive parameters require a directional tag indicating which way the data goes. Either in, out, or inout.
+
+Primitives are in by default, and cannot be otherwise
+
+Please note, RPC calls from clients are synchronous.
+You should limit the direction to what is truly needed, because marshaling parameters is expensive.
+Example: Please check the below AIDL interface to understand it in a better way.
+
+package com.hardian.sample.aidl;
+import com.hardian.sample.aidl.TeamMember;
+
+interface ITeamManageService {
+void getTeamCaptian(out TeamMember member);
+void updateTeamMember(inout TeamMember member, in boolean isLeader);
+oneway void removeTeamMember(in TeamMember member);
+}
+Here we have used out, in, inout directional tags to indicate which way the data goes.
+
+getTeamCaptian(out TeamMember member) : Get the captain of the team. Here the "out" directional tag means, when the client calls this method, the "member" object has no relevant data, but the server shall make changes to the "member" object, so the client shall get the updated "member" object. In fact, the method call is synchronous.
+
+updateTeamMember(inout TeamMember member, in boolean isLeader) : Update the captian of the team. Here the "inout" directional tag means, when the client calls this method,the "member" object has relevant data in it. And the server shall use the input data and process it. Once the process completed, the client shall get the relevant data back. In fact, the method call is synchronous.
+
+removeTeamMember(in TeamMember member) Remove a member from the team. Here the "in" directional tag means, the "member" object is transferred from client to service only used for inputs. If any changes are made to the "member" object in the service then it won’t reflect in the client. The method call is asynchronous, we can put the "oneway" keyword to the method signature. Asynchronous methods must not have "out" and "inout" arguments, they must also return void.
Index: app/src/main/assets/AndroidDoc/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/AndroidDoc/README.md b/app/src/main/assets/AndroidDoc/README.md
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/AndroidDoc/README.md	(date 1731353706000)
@@ -0,0 +1,10 @@
+# AndroidTraining
+
+1. ProcessThreadHandler
+- 
+2. ContentProvider
+   - Hình 1. Mối quan hệ giữa trình cung cấp nội dung và các thành phần khác.
+     ![image](https://github.com/minhngoc826/AndroidTraining/assets/23483531/c677daf9-0f9a-4c0e-95b9-73a99ccf0182)
+   - Hình 2. Hoạt động tương tác giữa ContentProvider, các lớp khác và bộ nhớ.
+     ![image](https://github.com/minhngoc826/AndroidTraining/assets/23483531/eafcda84-d0a5-4019-af14-6d788d78f4b1)
+
Index: app/src/main/assets/AndroidDoc/20.AD_GarbageCollectorAndReference.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/AndroidDoc/20.AD_GarbageCollectorAndReference.java b/app/src/main/assets/AndroidDoc/20.AD_GarbageCollectorAndReference.java
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/AndroidDoc/20.AD_GarbageCollectorAndReference.java	(date 1731353706000)
@@ -0,0 +1,83 @@
+// 8.GarbageCollectorAndReference.md
+
+// 1. Garbage Collector
+//   - Là chương trình chạy nền, theo dõi các đối tượng trong bộ nhớ, và tiến hành thu hồi bộ nhớ (quá trình Garbage Collection) của các đối tượng khi chúng không còn được tham chiếu đến.
+//   - 
+// 2. Reference: Một tham chiếu chỉ đến một đối tượng được khai báo, nhờ đó ta có thể truy cập được nó.
+//   - Strong reference: default, được tạo tự động khi new object, GC ko thể thu hồi nếu chưa remove tham chiếu (destroy or gán = null) hoặc đang còn strong tham chiếu phụ của obj khác đến nó
+//   - Weak reference: custom, GC có thể bỏ qua weak reference và thu hồi ngay obj khi remove tham chiếu của obj. các đối tượng weakly reachable object có thể truy cập qua method get() nếu như nó vẫn còn trong bộ nhớ.
+//   - Soft reference: giống weak nhưng GC ko thu hồi ngay mà cho vào ReferenceQueue và được thu hồi khi GC cần, GC đảm bảo thu hồi obj soft reference trc khi bị OOM, ưu tiên giữ lại những tham chiếu là recently-created hoặc recently-used. 
+//   - Phantom reference:
+
+// 1. Strong reference: Activity vs AsyncTask thường bị leak mem khi activity bị destroy mà AsyncTask đang chạy.
+public class StrongRefDemo {
+    static class MyObject {
+        @ Override
+        protected void finalize() throws Throwable {
+            super.finalize();
+            System.out.println("I'm collected!"); // will be printed if  MyObject is collected by GC
+        }
+    }
+    static MyObject obj;
+    public static void main(String[] args) throws InterruptedException {
+        System.out.println("Start");
+        obj = new MyObject(); // New strong reference is created.
+        obj = null; // To remove strong reference from obj
+        System.gc(); // Force to call Garbage collector
+        Thread.sleep(5000); // Wait GC finish its job
+        System.out.println("End");
+    }
+}
+
+// 2. Weak reference
+public static void main(String args[]) {
+    obj = new MyObject();
+    WeakReference<MyObject> weakObj = new WeakReference<>(obj)
+    obj = null; // obj is now eligible for garbage collection.
+    // System.gc(); // if gc run here, obj is completely collected
+    obj = weakObj.get(); // try to retrieve back obj
+}
+
+public class MainActivity extends Activity {
+    @ Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        new MyAsyncTask(this).execute();
+    }
+    private static class MyAsyncTask extends AsyncTask {
+        private WeakReference<MainActivity> mainActivity;
+
+        public MyAsyncTask(MainActivity mainActivity) {
+            this.mainActivity = new WeakReference<>(mainActivity);
+        }
+        @ Override
+        protected Object doInBackground(Object[] params) {
+            return doSomeStuff();
+        }
+        private Object doSomeStuff() {
+            //do something to get result
+            return new Object();
+        }
+        @ Override
+        protected void onPostExecute(Object object) {
+            super.onPostExecute(object);
+            if (mainActivity.get() != null){
+                //adapt contents
+            }
+        }
+    }
+}
+
+3. SoftReference
+SoftReference giống với WeakReference ở điểm nó có thể được thu hồi khi GC cần, tuy nhiên điểm khác biệt là trong khi WeakReference được thu hồi ngay lập tức, còn SoftReference lại phụ thuộc vào GC. Tất cả các SoftReference được cho vào các reference Queue và xóa khi cần. GC đảm bảo rằng tất cả các SoftReference tới các đối tượng softly reachable sẽ được thu hồi trước khi hệ thống văng lỗi OutOfMemory, ưu tiên giữ lại những tham chiếu là recently-created hoặc recently-used.
+
+Trong android, không khuyên khích việc sử dụng SoftReference cho việc tạo cache. Lý do là hệ thống sẽ không có đủ thông tin để xóa hoặc giữ tham chiếu nào và có thể dẫn đến tình trạng heap tăng cao. Việc thiếu thông tin này làm giảm công dụng của SoftReference, GC có thể thu hồi sớm những tham chiếu còn dùng, hoặc hao phí bộ nhớ khi giữ những tham chiếu không cần thiết. Vậy nên sử dụng android.util.LruCache thay cho SoftReference khi tạo cache.
+
+4. PhantomReference
+An object is phantom reachable if it is neither strongly nor softly nor weakly reachable and has been finalized and there is a path from the roots to it that contains at least one phantom reference.
+
+Một đối tượng là phantom reachable nếu như nó không phải là strongly, weakly hay softly reachable, đã ở trạng thái finalized (tức lúc GC xác định là không còn tham chiếu nào tới đối tượng này) và có 1 đường đi từ roots tới đối tượng đó chứa ít nhất 1 phantom reference
+
+Khác với các tham chiếu khác, PhantomReference không tự động bị thu hồi bởi GC mà nó sẽ được cho vào ReferenceQueue, một đối tượng phantom reachable sẽ tồn tại đến khi tất cả các tham chiếu bị hủy hoặc bản thân nó trở thành unreachable. Khác với WeakReference and SoftReference, hàm get() trong PhantomReference luôn trả về null
+
+// 3. Trong android, không khuyên khích việc sử dụng SoftReference cho việc tạo cache. Lý do là hệ thống sẽ không có đủ thông tin để xóa hoặc giữ tham chiếu nào và có thể dẫn đến tình trạng heap tăng cao. Việc thiếu thông tin này làm giảm công dụng của SoftReference, GC có thể thu hồi sớm những tham chiếu còn dùng, hoặc hao phí bộ nhớ khi giữ những tham chiếu không cần thiết. Vậy nên sử dụng android.util.LruCache thay cho SoftReference khi tạo cache.
Index: app/src/main/assets/AndroidDoc/07.Basic_DatabaseContentProvider.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/AndroidDoc/07.Basic_DatabaseContentProvider.java b/app/src/main/assets/AndroidDoc/07.Basic_DatabaseContentProvider.java
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/AndroidDoc/07.Basic_DatabaseContentProvider.java	(date 1731353706000)
@@ -0,0 +1,75 @@
+// 7.DatabaseContentProvider.java
+
+// https://developer.android.com/guide/topics/providers/content-provider-basics?hl=vi#ContentURIs
+
+1. Tổng quan:
+- Chia sẻ quyền truy cập vào dữ liệu ứng dụng của bạn với các ứng dụng khác
+- Gửi dữ liệu vào tiện ích
+- Trả về nội dung đề xuất tìm kiếm tuỳ chỉnh cho ứng dụng của bạn thông qua khung tìm kiếm bằng SearchRecentSuggestionsProvider
+- Đồng bộ hoá dữ liệu ứng dụng với máy chủ của bạn bằng cách triển khai AbstractThreadedSyncAdapter
+- Tải dữ liệu trong giao diện người dùng bằng CursorLoader (dùng kèm CursorAdapter và ListView thì yêu cầu 1 cột trong Cursor phải là _ID)
+
+- Quyết định xem bạn có cần một trình cung cấp nội dung hay không. Bạn cần xây dựng một trình cung cấp nội dung nếu muốn cung cấp một hoặc nhiều tính năng sau:
+  + Bạn muốn cung cấp dữ liệu hoặc tệp phức tạp cho các ứng dụng khác.
+  + Bạn muốn cho phép người dùng sao chép dữ liệu phức tạp trong ứng dụng của mình sang các ứng dụng khác.
+  + Bạn muốn cung cấp cụm từ tìm kiếm được đề xuất tuỳ chỉnh bằng khung tìm kiếm.
+  + Bạn muốn hiển thị dữ liệu ứng dụng của mình cho các tiện ích.
+  + Bạn muốn triển khai các lớp AbstractThreadedSyncAdapter, CursorAdapter hoặc CursorLoader.
+  
+
+2. Đọc dữ liệu bởi ứng dụng khác: 
+  - Nếu ContentProvider ko define permission nào, các ứng dụng khác sẽ ko có quyền truy cập
+  - ContentProvider: define permission read/write by <android:permission="read/write">: quyền này show ra bởi trình quản lý gói Android khi user cài đặt ứng dụng -> user OK thì mới cài.
+  - Other apps: declare permission <uses-permission> in manifest 
+      + từ API 30: thêm permission QUERY_ALL_PACKAGES + tag <queries> <package android:name="com.example.training"/> </queries>
+  - android:protectionLevel="signature": quyền truy cập được kiểm soát nhiều hơn vào dữ liệu của trình cung cấp nội dung khi ứng dụng truy cập vào dữ liệu đã ký bằng cùng một khoá.
+
+  - Quyền cố định cho URI: <path-permission>
+
+  - Truy cập bằng quyền tạm thời cho Uri: 
+    khi app ko có quyền vào ContentProvider thì có thể request qua 1 app khác đã được cấp quyền để lấy quyền tạm thời cho Uri, ko phải cho app
+    + ContentProvider: define permission for Uri, dùng "android:grantUriPermissions" or thẻ <grant-uri-permission> của <provider>
+    + Other apps: sent intent to app có quyền, setFlags FLAG_GRANT_READ_URI_PERMISSION/FLAG_GRANT_WRITE_URI_PERMISSION -> startActivityForResult() -> onActivityResult()
+    + Ví dụ: Contacts, send intent với ACTION_PICK, MIME CONTENT_ITEM_TYPE CONTACT = startActivityForResult() -> user select a contact -> trả kết quả trong onActivityResult()
+    + grantUriPermissions() / Context.revokeUriPermission()
+  
+  - Sử dụng ứng dụng khác: kích hoạt app khác có quyền rồi cho user thao tác trong app đó, ví dụ Calendar chấp nhận intent ACTION_INSERT
+
+  
+3. Protect data: avoid SQL injection
+  - String selectionClause = "var = " + userInput; (var = nothing; DROP TABLE *;) --> String selectionClause =  "var = ?";
+  - UriMatcher: match uri -> static mUriMatcher = new UriMatcher()
+
+    
+4. Thao tác CRUD
+  - Query: return Cursor
+  - Insert: return new uri -> get id = ContentUris.parseId(uri)
+  - Update: return count updated
+  - Delete: return count deleted
+  - Truy cập hàng loạt: dùng ContentProviderOperation operators -> ContentResolver.applyBatch(operators): inser, update nhiều row cùng lúc
+
+  - getType: 
+    + content://com.example.trains/Line1    --> vnd.android.cursor.dir/vnd.example.line1
+    + content://com.example.trains/Line2/5  --> vnd.android.cursor.item/vnd.example.line2
+  - getStreamTypes(): Loại MIME cho tệp
+
+  5. Data type
+    - primitive data:
+    - BLOB: byte[] ~ 64 KB
+
+  6. URI
+    + UriMatcher:
+    + Uri.Builder:
+    + ContentUris:
+    + Thuộc tính khởi động và điều khiển
+      Những thuộc tính này xác định cách thức và thời điểm hệ thống Android khởi động trình cung cấp, đặc điểm quy trình của trình cung cấp và các chế độ cài đặt thời gian chạy khác:
+      android:enabled: gắn cờ cho phép hệ thống khởi động trình cung cấp
+      android:exported: gắn cờ cho phép các ứng dụng khác dùng ứng dụng này
+      android:initOrder: thứ tự bắt đầu trình cung cấp này, so với các trình cung cấp khác trong cùng một quy trình
+      android:multiProcess: gắn cờ cho phép hệ thống khởi động trình cung cấp trong cùng một quy trình với ứng dụng gọi
+      android:process: tên của quy trình mà trình cung cấp chạy
+      android:syncable: cờ cho biết rằng dữ liệu của nhà cung cấp sẽ được đồng bộ hoá với dữ liệu trên máy chủ
+      Các thuộc tính này được ghi lại đầy đủ trong hướng dẫn về phần tử <provider>.
+  
+
+
Index: app/src/main/assets/AndroidDoc/00.Basic_ProcessThreadHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/AndroidDoc/00.Basic_ProcessThreadHandler.java b/app/src/main/assets/AndroidDoc/00.Basic_ProcessThreadHandler.java
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/AndroidDoc/00.Basic_ProcessThreadHandler.java	(date 1731353706000)
@@ -0,0 +1,17 @@
+iconDrawable.let { drawable ->
+    val scaleX = lerp(0f, 1f, scaleIconFraction)
+    val scaleY = scaleX
+    val pivotX = width / 2f
+    val pivotY = height / 2f
+    canvas.withScale(scaleX, scaleY, pivotX, pivotY) {
+        // rotate the icon if it appears
+        if (scaleIconFraction > 0) {
+            invalidate()
+        }
+        rotate(iconDegree, pivotX, pivotY)
+        // Anticlockwise direction
+        val iconSpeed = 6
+        iconDegree = (iconDegree - iconSpeed) % 360
+        drawable.draw(canvas)
+    }
+}
Index: app/src/main/assets/AndroidDoc/21.AD_SerializableParcelable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/AndroidDoc/21.AD_SerializableParcelable.java b/app/src/main/assets/AndroidDoc/21.AD_SerializableParcelable.java
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/AndroidDoc/21.AD_SerializableParcelable.java	(date 1731353706000)
@@ -0,0 +1,158 @@
+// Serializable vs Parcelable
+
+    /*
+    * I. Serializable: bậc thầy của sự đơn giản
+    *   - Sử dụng sự ánh xạ (reflection) để suy ra các kiểu DL + object nên tốn time, cả time đọc ghi
+    *   - Tạo nhiều Object rác -> tốn time dọn rác
+    * II. Parcelable: Vua tốc độ, ~ x10 lần Serializable
+    *   - Parcelable cho hiệu năng rất tốt với Android do triển khai rõ ràng về quá trình đọc ghi tuần tự, tuy nhiên nó lại có quá nhiều code thừa.
+    *   - Và mỗi khi model thay đổi thì ta sẽ cần phải update lại code parcelable.
+    *
+    * III. Các class impl Serializable/Parcelable thì subClass cũng phải impl Serializable/Parcelable
+    *   - SubClass impl Serializable phải có ít nhất 1 constructor no-args để đảm bảo quá trình Serialization, nếu ko sẽ raise error khi runtime.
+    * */
+
+    /* I. Serializable:
+    * Serialization:
+    *   - Là quá trình chuyển các cấu trúc dữ liệu và các đối tượng thành một định dạng có thể lưu trữ được (vào file, in-memory buffer, hoặc truyền qua network),
+    *   - Sau đó có thể phục hồi lại các cấu trúc dữ liệu và đối tượng như ban đầu, trên cùng hoặc khác môi trường.
+    *   - sử dụng sự ánh xạ (reflection) để suy ra các kiểu DL + object
+    *
+    * Thuật toán Serialization sẽ thực hiện các công việc sau:
+    *   - Ghi xuống các siêu dữ liệu (metadata) về class (ví dụ như tên của class, version của class, tổng số các field của class,….) của đối tượng đó.
+    *   - Ghi đệ quy các thông tin class cho tới khi nó gặp class Object. (các fields)
+    *   - Ghi các dữ liệu của các đối tượng
+    *
+    * Tuần tự hóa có ba mục đích chính sau
+    *   - Cơ chế ổn định: Nếu luồng được sử dụng là FileOuputStream, thì dữ liệu sẽ được tự động ghi vào tệp.
+    *   - Cơ chế sao chép: Nếu luồng được sử dụng là ByteArrayObjectOuput, thì dữ liệu sẽ được ghi vào một mảng byte trong bộ nhớ.
+    *       Mảng byte này sau đó có thể được sử dụng để tạo ra các bản sao của các đối tượng ban đầu.
+    *   - Nếu luồng đang được sử dụng xuất phát từ một Socket thì dữ liệu sẽ được tự động gửi đi tới Socket nhận,
+    *       khi đó chương trình nhận sẽ quyết định phải làm gì đối với dữ liệu nhận được (giải mã để có được dữ liệu của đối tượng)
+    *
+    * Tại sao lại cần đến Serialization?
+    *   - Một hệ thống enterprise điển hình thường có các thành phần nằm phân tán rải rác trên các hệ thống và mạng khác nhau.
+    *       Trong Java mọi thứ đều được miêu tả như là một object. Nếu 2 thành phần Java cần liên lạc với nhau, ta cần phải có một cơ chế để chúng trao đổi dữ liệu.
+    *       Serialization được định nghĩa cho mục đích này, và các thành phần Java sẽ sử dụng giao thức (protocol) này để truyền các object qua lại với nhau.
+    *   - Có thể dùng trao đối dữ liệu giữa 2 hệ thông khác nhau sử dụng thuật tóan tuần tự hóa mà không phụ thuộc vào nền tảng giữa chúng.
+    * */
+
+    /* II. Parcelable:
+    *   - writeToParcel(): triển khai ghi tất cả dữ liệu có trong lớp tới Parcel
+    *   - Parcelable.Creator: để giải tuần tự tái tạo lại Java Object
+    *
+    * Java - Parcelable: lib AutoValue (https://github.com/google/auto/blob/main/value/userguide/index.md)
+    * Kotlin - Parcelable: @Parcelize - tự động implement Parcelable
+    *   Require:
+    *   Kotlin 1.4.0
+    *   build.gradle:
+    *       apply plugin: ‘kotlin-android-extensions’
+            androidExtensions {
+                experimental = true
+            }
+    * */
+
+    /* So sánh Parcelable và Serializable
+    Serializable:
+        Ưu điểm:
+            Cực kì dễ triển khai, ít yêu cầu kèm theo
+            Có thể ghi đối tượng xuống dạng tệp tin để lưu trữ xuống ổ đĩa, và có thể đọc ở nhìu hệ thống khác nhau
+        Nhược điểm:
+            Nó có tốc độ chậm, sinh ra nhiều đối tượng rác (garbage )
+            Nó rất khó để bảo trì (maintain) nếu bạn thay đổi cấu trúc của class.
+    Parcelable:
+        Ưu điểm:
+            Nó nhanh hơn Serializable
+            Dễ dàng đánh phiên bản cho đối tượng
+            Kiểm soát được dữ liệu tuần tự
+        Nhược điểm:
+            Nó phụ thuộc vào nên tảng (hiện tại phương thức này chỉ áp dụng cho android)
+            Vì chỉ tồn tại trong vòng đời của Activity nên dữ liệu không được ghi xuống file
+            Triển khai khó khăn hơn. Cấu trúc dữ liệu của Object thay đổi là cần thay đổi 1 trình tự đọc và ghi của phương thức.*/
+
+    /*
+    * - Serializable according to the docs can also be done in a manual way, using writeObject(ObjectOutputStream) and readObject(ObjectInputStream) methods.
+    *   This is how it should be done for the best performance (faster than Parcelable, https://github.com/minhngoc826/Android-Serialization-Test/tree/master)
+    *   @Doc:  http://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html
+    *   +  writeObject(ObjectOutputStream out): invoke out.defaultWriteObject to writing fields to the stream -> then write primitive data by DataOutput
+    *   + readObject(ObjectInputStream in): invoke in.defaultReadObject to read fields from the stream -> then read primitive data by DataInput
+    *   + Serializable should define "serialVersionUID" for faster, if not serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class.
+    *
+    *
+    * - If serializable is faster and easier to implement, why android has parcelable at all?
+    *   The reason is native code. Parcelable is created not just for interprocess communication.
+    *   It also can be used for intercode communication. You can send and recieve objects from C++ native layer. That's it.
+    * */
+
+    class SerializableExample {
+
+        public void testParcelable() {
+            TreeNode root = createNode(0);
+            Parcel parcel = Parcel.obtain();
+
+            long start = System.nanoTime();
+
+            root.writeToParcel(parcel, 0);
+
+            long finish = System.nanoTime();
+
+            int length = parcel.marshall().length;
+            parcel.setDataPosition(0); // reset for reading
+
+            long start2 = System.nanoTime();
+            TreeNode restored = TreeNode.CREATOR.createFromParcel(parcel);
+
+            long finish2 = System.nanoTime();
+            System.out.println(restored);
+            parcel.recycle();
+        }
+
+        public void testSerializable() {
+            TreeNode root = createNode(0);
+
+            ObjectOutputStream out = null;
+            ByteArrayOutputStream bas = new ByteArrayOutputStream(1_000_000);
+
+            long start = System.nanoTime();
+            try {
+                out = new ObjectOutputStream(bas);
+                out.writeObject(root);
+
+            } catch (Exception e) {
+                e.printStackTrace();
+            } finally {
+                if (out != null) {
+                    try {
+                        out.close();
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+
+            long finish = System.nanoTime();
+            byte[] byteArray = bas.toByteArray();
+            int length = byteArray.length;
+            ByteArrayInputStream bis = new ByteArrayInputStream(byteArray);
+            ObjectInputStream in = null;
+            TreeNode restored = null;
+
+            long start2 = System.nanoTime();
+            try {
+                in = new ObjectInputStream(bis);
+                restored = (TreeNode) in.readObject();
+            } catch (Exception e) {
+                e.printStackTrace();
+            } finally {
+                if (in != null) {
+                    try {
+                        in.close();
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+            long finish2 = System.nanoTime();
+            System.out.println(restored);
+        }
+    }
Index: app/src/main/assets/AndroidDoc/04.Basic_BroadcastReceiver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/AndroidDoc/04.Basic_BroadcastReceiver.java b/app/src/main/assets/AndroidDoc/04.Basic_BroadcastReceiver.java
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/AndroidDoc/04.Basic_BroadcastReceiver.java	(date 1731353706000)
@@ -0,0 +1,1 @@
+// 4.BroadcastReceiver.java
Index: app/src/main/assets/AndroidDoc/01.Basic_ActivityFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/AndroidDoc/01.Basic_ActivityFragment.java b/app/src/main/assets/AndroidDoc/01.Basic_ActivityFragment.java
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/AndroidDoc/01.Basic_ActivityFragment.java	(date 1731353706000)
@@ -0,0 +1,115 @@
+// 1.ActivityFragment.java
+
+// 1. Activity
+
+
+// 2. Fragment:			https://developer.android.com/guide/fragments/transactions?hl=en
+// 2.1. Common
+- Setup: AndroidX Fragment
+	+ build.gradle: 	implementation "androidx.fragment:fragment:$fragment_version"		// Java language implementation
+						implementation "androidx.fragment:fragment-ktx:$fragment_version"	// Kotlin
+	+ settings.gradle: 	 Bạn cần thêm kho lưu trữ Google Maven
+
+- Define: ExampleFragment extends Fragment {
+	public ExampleFragment() {
+        super(R.layout.example_fragment);
+    }
+ }
+
+- Types:
+	+ Fragment:
+		- AppCompatActivity extnends FragmentActivity: should use FragmentContainerView (Activity created -> FragmentContainerView: onInflate() -> inflate fragment
+	+ DialogFragment: Displays a floating dialog. https://developer.android.com/guide/fragments/dialogs
+	+ PreferenceFragmentCompat: Displays a hierarchy of Preference objects as a list. https://developer.android.com/develop/ui/views/components/settings
+
+- Method:
+	+ Lifecycle: onAttach -> onCreate -> onCreatedView -> onStart -> onResume -> onStop -> onPause -> onDestroyView -> onDestroy -> onDetach -> Finish.
+	+ onAttach: set context
+	+ onCreatedView: inflate layout to view -> return view: findViewById, setOnClickListener, ...
+	+ get bundleData: requireArguments()
+	+ khi add fragment to activity, sau đó activity đc recreate, fragment đc tự động khôi phục từ savedInstanceState.
+	+ Fragment can contains other fragment (child fragments)
+	
+- Back stack: same back stack of activity
+	+ addToBackStack: getSupportFragmentManager().beginTransaction().replace(R.id.fragment_container_adapter, ListViewFragment.class, "list_view_fragment")
+												 .setReorderingAllowed(true).addToBackStack("list_view_fragment").commit();
+	+ find fragment: getSupportFragmentManager().findFragmentByTag("list_view_fragment")
+	 				 getSupportFragmentManager()..findFragmentById(R.id.fragment_container_adapter)
+	+ popBackStack:
+	+ ...
+	
+
+// 2.2. FragmentManager: getSupportFragmentManager() from activity or fragment
+- At runtime, a FragmentManager can add, remove, replace, and perform other actions with fragments in response to user interaction.
+- getSupportFragmentManager() / getChildFragmentManager() / getParentFragmentManager():
+	+ Activity: contains Fragment -> getSupportFragmentManager()
+	+ Fragment: contains childFragments
+		- getParentFragmentManager() = getSupportFragmentManager() - activity
+		- getChildFragmentManager() = getParentFragmentManager()-childFragments
+	+ childFragments:
+		- getParentFragmentManager() = getChildFragmentManager() - Fragment
+	
+- FragmentFactory: Provide dependencies to your fragments
+	+ public class MyFragmentFactory extends FragmentFactory {
+			private DessertsRepository repository;
+
+- addToBackStack(): STOPPED -> RESUMED khi user back
+
+- setPrimaryNavigationFragment()
+
+- Support multiple back stacks: first, addToBackStack(tag), then
+	+ saveBackStack(tag): need setReorderingAllowed(), same popBackStack
+	+ restoreBackStack(tag)
+	
+
+// 2.3. FragmentTransaction: getSupportFragmentManager().beginTransaction() -> Add operations -> commit()
+- setReorderingAllowed(true): Each FragmentTransaction should use setReorderingAllowed(true), tối ưu hoá các thay đổi về trạng thái của các mảnh có liên quan trong giao dịch để các ảnh động và hiệu ứng chuyển tiếp hoạt động chính xác
+- add(fragment, bundleData): fragment is RESUMED, nên dùng khi container là FragmentContainerView
+- remove(fragment): fragment is DESTROYED.
+- replace(fragment, bundleData): = remove + add
+- commit():	is asynchronous(không đồng bộ) -> the transaction is scheduled to run on the main UI thread as soon as it is able to do so
+	+ all commit can run now by calling: executePendingTransactions() & support addToBackStack
+- commitNow(): run the fragment transaction on your UI thread immediately, but not support addToBackStack
+- setCustomAnimations():	fragmentManager. beginTransaction()
+										   .setCustomAnimations(enter1, exit1)
+										   .add(MyFragmentClass, args, tag1) // this fragment gets the first animations
+										   .setCustomAnimations(enter2, exit2)
+										   .add(MyFragmentClass, args, tag2) // this fragment gets the second animations
+										   .commit()
+- setMaxLifecycle(): Limit the fragment's lifecycle
+- show & hide(fragment): These methods set the visibility of the fragment's views without affecting the lifecycle of the fragment.
+- attach() & detach():  not call detach then call attach, should be call: detach -> commit & executePendingOperations() = commitNow -> attach
+	+ detach = STOPPED & destroying its view hierarchy & removed from UI, but not DESTROYED, FragmentManager can managed it.
+	+ attach = create its view hierarchy & attached & displayUI
+	
+- Notes: khi add fragment nên dùng class thay vì instance để đảm bảo rằng các cơ chế tạo fragment này cũng được dùng để khôi phục fragment từ một trạng thái đã lưu.
+
+
+/////////////////////
+//pick an easily remembered tag
+public void replace(Fragment fragment, String tag){
+	FragmentManager man = dashboard.support;
+	FragmentTransaction fragt = man.beginTransaction();
+
+	if(!fragment.isAdded()) {
+		dashboard.lastTag = dashboard.fragtag;//not needed, but helpful w/ backpresses
+		fragt.add(R.id.fragment_container, fragment, tag)
+				.hide(man.findFragmentByTag(fragtag)).commit();
+		dashboard.fragtag = dashboard.tag;//not needed, but helpful w/ backpresses
+	}
+	if(fragment.isAdded() && fragment.isHidden()) {
+		dashboard.lastTag = dashboard.fragtag;//not needed, but helpful w/ backpresses
+		fragt.show(fragment);
+		fragt.hide(man.findFragmentByTag(fragtag)).commit();
+		dashboard.fragtag = dashboard.tag;//not needed, but helpful w/ backpresses
+	}
+}
+
+@Override
+public void onBackPressed() {
+    FragmentManager man = getSupportFragmentManager();
+    FragmentTransaction fragmentTransaction = man.beginTransaction();
+    fragmentTransaction.hide(getSupportFragmentManager().findFragmentByTag(fragtag))
+    .show(getSupportFragmentManager().findFragmentByTag(lastTag)).commit();
+    fragtag = lastTag;// holds the last fragment
+}
Index: app/src/main/assets/4.AndroidAppElement.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/4.AndroidAppElement.txt b/app/src/main/assets/4.AndroidAppElement.txt
new file mode 100644
--- /dev/null	(date 1729881921418)
+++ b/app/src/main/assets/4.AndroidAppElement.txt	(date 1729881921418)
@@ -0,0 +1,56 @@
+// https://developer.android.com/develop/ui/views/animations/transitions/start-activity#start-with-element
+
+1. App Layout
+	- Responsive layout
+	- Dynamic list
+	- Activity embeding
+	- Window size classes
+	- Support Multi-window
+	- improve layout performance
+	- custom view
+	- window insets & cutouts
+	- web-based content
+
+2. Apply theme
+	- Dynamic color
+	- Material Design
+	- Implement dark theme
+	- shadows & clip
+	
+3. Add components: core components, app bar, settings, Android search
+
+4. Text & Emoji
+	- download font
+	- add emoji
+	- autosize text view
+	
+5. Display graphics & video
+	- static images
+	- media playback controls
+	- video using PiP (picture-in-picture)
+	
+	
+6. Animations & Transitions
+	- Motion Layout
+	- Activity vs animation
+	- fragments slide with Viewpager
+
+7. Touch & Input
+	- spelling & checker
+	- ...
+	
+8. App Notification
+	- permission
+	- expandable notification
+	- notification chanel / group
+	- conversations
+	- pop-up messages
+
+9. App launch
+	- adaptive launcher icon
+	- splash screen
+	- app shortcuts
+	
+10. add app content to home screen or launcher
+
+11. Backward-compatible UIs
\ No newline at end of file
Index: app/src/main/assets/3.AppArchitecture.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/3.AppArchitecture.txt b/app/src/main/assets/3.AppArchitecture.txt
new file mode 100644
--- /dev/null	(date 1729881884032)
+++ b/app/src/main/assets/3.AppArchitecture.txt	(date 1729881884032)
@@ -0,0 +1,8 @@
+4. App Architecture
+	- 4.1. Overview
+	- 4.2. Modularization
+	- 4.3. Architecture Components
+	- 4.4. App entry points
+	- 4.5. App Naigation
+	- 4.6. Dependencies Injection
+	- 4.7. App Startup
\ No newline at end of file
Index: app/src/main/assets/2.AppNavigation.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/2.AppNavigation.txt b/app/src/main/assets/2.AppNavigation.txt
new file mode 100644
--- /dev/null	(date 1730796973314)
+++ b/app/src/main/assets/2.AppNavigation.txt	(date 1730796973314)
@@ -0,0 +1,443 @@
+// Contents
+
+1. Overview: 
+	- Class: 				NavGraph, NavHostController, NavHost/NavHostFragment, NavDestination, Route(NavBackStackEntry.toRoute<Route>(), SavedStateHandle.toRoute<Route>(), NavArgument)
+							NavGraphBuilder, NavType, NavDeepLinkRequest, NavAction
+	- Navigate:				composable(route = xx) { ComposableScreen() } = composable<route> { backStackEntry -> ComposableScreen() }
+	- Destination types:	hosted, dialog, activity	-> composable<route> {}, dialog<route> {} / dialog<Fragment, route> {}, activity<route> {}, fragment<Fragment, route> {}
+2. Navigation:
+	- Compose:		composable<route> {}
+	- Fragment:		fragment<Fragment, route> {}
+3. Destination:
+	- Dialog:					dialog<route> {} / dialog<Fragment, route> {}
+	- Activity:					activity<route> { label = ""	activityClass = MyActivity::class }
+	- Custom Destination type: 	add new Navigator to NavController --> using getNavigatorProvider().addNavigator(navigator)
+4. Nested Graph:
+				- NavHost(navController, startDestination = Start) {
+					composable<Start>, composable<Register>, navigation<Game>(startDestination = Match) { composable<Match>, composable<InGame>, composable<ResultWinner>, composable<GameOver> }
+				}
+5. Deep links: handleDeepLink() <-- onNewIntent()
+	- explicit:	NavDeepLinkBuilder(context).setGraph(R.navigation.nav_graph).setDestination(R.id.android).setArguments(args).setComponentName().createPendingIntent() / NavController.createDeepLink()
+	- implicit:	
+		+ <deepLink app:uri/action/mimeType/> 		& 		<activity> <nav-graph android:value="@navigation/nav_graph" /> </activity> 
+		+ deepLink<Route> { basePath = "" 	action = "" 	mimeType="" }
+6. Type safety:
+	- @Serializable object Route	/ 	@Serializable data class Route(params: String)
+7. Encapsulate navigation
+	- NavGraphBuilder.extendDestination()
+	- NavController.extendNavigate()
+	- Using internal: 
+8. Animations
+9. 
+
+
+// Details
+
+1. Overview
+	- gradle: "androidx.navigation:navigation-compose:version"  / navgation-compose/ -fragment/ -ui/ -dynamic-features-fragment/ -testing
+
+	- NavGraph:					map composable - destination
+	- NavHostController:		navigate = redirect ( = rememberNavController() )
+		+ contains list[Navigator] -> navigate:
+			- Activity:	using ActivityNavigator & ActivityNavigator.Destination
+			- Fragment:	using FragmentNavigator (NavHostFragment add FragmentNavigator to NavController)
+	- NavHost/NavHostFragment:	show destination base on route (Composable show another composable base on route)  ( = supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment )
+	- NavDestination:		
+	- Route:					Any serializable data type.
+	
+	- find navController:
+		+ Fragment.findNavController() 						+ NavHostFragment.findNavController(Fragment)					 = NavHostFragment.navController  
+		+ View.findNavController()							+ Navigation.findNavController(Activity, @IdRes int viewId)
+		+ Activity.findNavController(viewId: Int)			+ Navigation.findNavController(View)
+		
+	- Destination types:
+		+ hosted: 	same size, previous destinations are not visible 				-> Main & details screen
+			- composable<Home> { HomeScreen(onNavigateToSettings = { navController.navigate(route = Settings) }) }
+		+ dialog:	overlay UI, previous destinations are visible underneath		-> Alert, selections, forms
+			- dialog<Settings> { SettingsScreen() }
+		+ activity:	exit point to the navigation graph when interacting with third party activities or as part of the migration process
+			- activity<MyRoute> {
+				label = getString(R.string.activity_title)
+				// custom argument types, deepLinks...
+				activityClass = MyActivity::class 
+			}
+	
+	- Benefit:
+		+ Animations and transitions: Provides standardized resources for animations and transitions.
+		+ Deep linking: Implements and handles deep links that take the user directly to a destination.
+		+ UI patterns: Supports patterns such as navigation drawers and bottom navigation with minimal additional work.
+		+ Type safety: Includes support for passing data between destinations with type safety.
+		+ ViewModel support: Enables scoping a ViewModel to a navigation graph to share UI-related data between the graph's destinations.
+		+ Fragment transactions: Fully supports and handles fragment transactions.
+		+ Back and up: Handles back and up actions correctly by default.
+	
+	
+2. Navigation:
+	- 2.1. Compose 
+		+ Using NavHost(): As part of the NavHost
+			NavHost(navController = rememberNavController(), startDestination = Profile) {
+				composable<Profile> { ProfileScreen( /* ... */ ) }
+				composable<FriendsList> { FriendsListScreen( /* ... */ ) }
+				// Add more destinations similarly.
+				composable(route = FriendsList) { FriendsListScreen( /* ... */ ) }
+			}
+			
+		+ Programmatically: NavController.createGraph()
+			val navGraph by remember(navController) {
+			  navController.createGraph(startDestination = Profile)) {
+				composable<Profile> { ProfileScreen( /* ... */ ) }
+				composable<FriendsList> { FriendsListScreen( /* ... */ ) }
+			  }
+			}
+			NavHost(navController, navGraph)
+			
+		+ Pass param to destination: @Serializable
+			- object Profile / data object Profile: 	no param			~= Profile::class (KClass<T>)
+			- data class Profile(val name: String):		pass param
+			
+		+ Navigate:
+			- current route: = NavBackStackEntry.toRoute<Route>() / SavedStateHandle.toRoute<Route>()
+				composable<Profile> { backStackEntry ->
+					val profile: Profile = backStackEntry.toRoute<Profile>()
+					ProfileScreen(name = profile.name)
+				}
+
+
+	- 2.2. Fragment
+		+ Programmatically: 		NavHostFragment -> createGraph
+			- NavHostFragment: XML -> layout -> FragmentContainerView: id/nav_host_fragment"		name = "androidx.navigation.fragment.NavHostFragment"		and without navGraph attribute
+			- code:
+				+ find navController: val navController = findNavController(R.id.nav_host_fragment)
+				+ createGraph: fragment<ProfileFragment, Profile> { label = "Profile" }					fragment<FriendsListFragment, FriendsList>() { label = "Friends List" }
+		
+		+ XML:
+			- NavHostFragment: XML -> layout -> FragmentContainerView: id/nav_host_fragment"		name = "androidx.navigation.fragment.NavHostFragment"		app:navGraph="@navigation/nav_graph"
+			- navigation: 
+				+ <navigation xmlns:android="http://schemas.android.com/apk/res/android"
+					xmlns:app="http://schemas.android.com/apk/res-auto"
+					android:id="@+id/nav_graph"
+					app:startDestination="@id/profile">
+					<fragment
+						android:id="@+id/profile"
+						android:name="com.example.ProfileFragment"
+						android:label="Profile">
+						<action												<!-- Action to navigate from Profile to Friends List. -->
+							android:id="@+id/action_profile_to_friendslist"			<-- navigate: 
+							app:destination="@id/friendslist" />
+					</fragment>
+					<fragment
+						android:id="@+id/friendslist"
+						android:name="com.example.FriendsListFragment"
+						android:label="Friends List" />
+				</navigation>
+			
+			- 
+		
+		+ Android Studio editor: 	
+	
+
+3. Destination
+	- 3.1. Dialog:
+		+ Compose:
+			- dialog<Settings> { SettingsScreen() }
+			
+		+ Fragment:
+			- navController.graph = navController.createGraph( startDestination = Home ) { // Add the graph to the NavController with `createGraph()`.
+				fragment<HomeFragment, Home> { // Associate the home route with the HomeFragment.
+					label = "Home"
+				}
+				dialog<SettingsFragment, Settings> { // Define the settings destination as a dialog using DialogFragment.
+					label = "Settings"
+				}
+			}
+			
+		+ XML:
+			- <?xml version="1.0" encoding="utf-8"?>
+			<navigation xmlns:android="http://schemas.android.com/apk/res/android"
+						xmlns:app="http://schemas.android.com/apk/res-auto"
+						android:id="@+id/nav_graph">
+				...
+				<dialog
+					android:id="@+id/my_dialog_fragment"
+					android:name="androidx.navigation.myapp.MyDialogFragment">
+					<argument android:name="myarg" android:defaultValue="@null" />
+						<action
+							android:id="@+id/myaction"
+							app:destination="@+id/another_destination"/>
+				</dialog>
+			...
+			</navigation>
+		
+
+	- 3.2. Activity:
+		+ Programmatically:
+			- activity<MyRoute> {
+				label = getString(R.string.activity_title)
+				// custom argument types, deepLinks...
+				activityClass = MyActivity::class 
+			}
+		
+		+ XML:
+			- <?xml version="1.0" encoding="utf-8"?>
+			<navigation xmlns:android="http://schemas.android.com/apk/res/android"
+				xmlns:app="http://schemas.android.com/apk/res-auto"
+				android:id="@+id/navigation_graph"
+				app:startDestination="@id/simpleFragment">
+
+				<activity
+					android:id="@+id/localDestinationActivity"
+					android:label="@string/localActivityTitle"
+					
+					// = startActivity(Intent(context, DestinationActivity::class.java))
+					android:name="com.example.android.navigation.activity.DestinationActivity"
+					app:targetPackage="com.example.android.another.app" 							// using for owner app or another app
+					//
+					
+					// if activity has intent-filter: action, data
+					app:action="android.intent.action.VIEW"
+					app:data="https://example.com"
+					//
+					
+					// Dynamic argument for data
+					app:dataPattern="https://example.com?userId={userId}"							<-- set argument: navController.navigate( R.id.localDestinationActivity, bundleOf("userId" to "someUser") )
+					<argument
+						android:name="userId"
+						app:argType="string" />
+					//
+				/>
+			</navigation>
+	
+	- 3.3. Custom Destination: add new Navigator to NavController --> using getNavigatorProvider().addNavigator(navigator)
+		+ val customNavigator = CustomNavigator()			-->			navController.navigatorProvider += customNavigator
+		+ unary plus operator: 	+navigatorProvider[CustomNavigator::class].createDestination().apply { route = Graph.CustomDestination.route }
+		+ add:					val customDestination = navigatorProvider[CustomNavigator::class].createDestination().apply { route = Graph.CustomDestination.route }
+								addDestination(customDestination)
+								
+		+ destination arguments: need @Serializable
+			- custom types with NavType: https://developer.android.com/guide/navigation/design/kotlin-dsl?hl=en
+		
+
+4. Nested graph:					https://developer.android.com/guide/navigation/design/nested-graphs?hl=vi
+	- Game's routes flow: 			Start -> Register -> 						Match -> InGame (play game) -> ResultWinner/ GameOver -> Match
+	- Create nested graph:			Start -> Register -> Game(Nested graph) ->	Match -> InGame (play game) -> ResultWinner/ GameOver -> Match
+	- Code: NavHost(navController, startDestination = Start) {
+				composable<Start>, composable<Register>, navigation<Game>(startDestination = Match) { composable<Match>, composable<InGame>, composable<ResultWinner>, composable<GameOver> }
+			}
+	- XML:
+		+ <navigation> 
+			<navigation id=action_mainFragment_to_sendMoneyGraph>  			<-- view.findNavController().navigate(R.id.action_mainFragment_to_sendMoneyGraph)
+				<fragment /> 
+			</navigation>
+		</navigation>
+		
+		+ <include>: same include layout
+		
+5. Deep links:
+	- explicit: NavDeepLinkBuilder / NavController.createDeepLink()  --> the task back stack is cleared and replaced with the deep link destination, include the start destination of nested-graph
+		+ pendingIntent = NavDeepLinkBuilder(context).setGraph(R.navigation.nav_graph).setDestination(R.id.android).setArguments(args).createPendingIntent()
+			.setComponentName(DestinationActivity::class.java / ComponentName)  // if NavHost is in other activity
+		
+	- implicit: ordered URI > action > mime
+		+ declare: 		<deepLink app:uri="http://www.example.com/users/{id}" app:action="" app:mimeType="" />
+		+ manifest:		add tag <nav-graph android:value="@navigation/nav_graph" /> to activity that handle deepLink	
+			-> When building project, the Navigation component replaces the <nav-graph> element with generated <intent-filter> elements to match all of the deep links in the navigation graph.
+		+ state of backstack: implicit Intent launched
+			- with  Intent.FLAG_ACTIVITY_NEW_TASK:		the task back stack is cleared and replaced with the deep link destination, include the start destination of nested-graph 	
+				--> Back button: navigate back up the navigation stack just as though they entered your app from its entry point
+			- without  Intent.FLAG_ACTIVITY_NEW_TASK:	remain on the task stack of the previous app where the implicit deep link was triggered 									
+				--> Back button: back to previous app 
+				--> Up button: starts your app's task on the hierarchical parent destination within your navigation graph.
+		
+		+ deepLink<Route> { basePath = "" 	action = "" 	mimeType="" }
+	+ handle deepLinks: with launchMode
+		- standard (default): 	handleDeepLink() --> any explicit or implicit deep links within the Intent
+		- singleTop:			handleDeepLink() <-- onNewIntent()
+		
+		
+6. Type safety
+	- @Serializable object Route	/ 	@Serializable data class Route(params: String)
+
+
+7. Encapsulate navigation: extend NavGraphBuilder, NavController
+	- SubNavigation.kt:		
+		+ destination:		
+			- fun NavGraphBuilder.contactsDestination()  		{ composable<Contacts> { ContactsScreen( /* ... */ ) } }
+			- fun NavGraphBuilder.contactDetailsDestination() 	{ composable<ContactDetails> { navBackStackEntry -> ContactDetailsScreen(contact = navBackStackEntry.toRoute<Contacts>()) } }
+		+ navigate:			
+			- fun NavController.navigateToContactDetails(id: String) { navigate(route = ContactDetails(id = id) }
+			
+	- AppScreen.kt:	fun MyApp() {
+					  ...
+					  NavHost(navController, startDestination = Contacts) {
+						contactsDestination(onNavigateToContactDetails = { contactId -> navController.navigateToContactDetails(id = contactId) }) 
+						contactDetailsDestination()
+						...
+					  }
+					}
+	- Using internal: to keep screens and route types private
+		
+
+8. Global actions:
+	- Safe Args:
+		+ XML: <fragment> 	<action android:id="@+id/action_fragmentA_to_fragmentB" app:destination="@id/fragmentB" /> 		</fragment>
+		+ Code: navController.navigate(R.id.action_fragmentA_to_fragmentB)
+		
+		+ Global actions:
+			
+		
+	- Animations:
+		+ 
+
+
+9. Using NavGraph
+	- 9.1. Navigate:
+		+ Composable: 					navController.navigate(route = FriendsList)
+		+ using ID:						view.findNavController().navigate(R.id.viewTransactionsAction)
+		+ using NavDeepLinkRequest: 	val request = NavDeepLinkRequest.Builder.fromUri("android-app://androidx.navigation.app/profile".toUri()).build()	-->		findNavController().navigate(request)
+	
+	- 9.2. Navigate with options: NavOptions
+		+ XML:
+		+ Code:	findNavController().navigate(
+					R.id.action_fragmentOne_to_fragmentTwo,  // or deepLinkUri
+					null, 
+					navOptions { // Use the Kotlin DSL for building NavOptions
+						anim {
+							enter = android.R.animator.fade_in
+							exit = android.R.animator.fade_out
+							popEnter = / popExit = / popUpTo / popUpToInclusive
+						}
+					}
+				)
+		+ 
+	
+	- 9.3. Safe-args:
+		+ gradle:	android.useAndroidX=true
+			- buildscript -> dependencies: classpath("androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version")
+			- plugins { id("androidx.navigation.safeargs") id("androidx.navigation.safeargs.kotlin") }
+			
+		+ Gen class: SpecifyAmountFragment -> SpecifyAmountFragmentDirections
+		+ Using:
+			- override fun onClick(v: View) {
+				val amount: Float = ...
+				val action = SpecifyAmountFragmentDirections.actionSpecifyAmountFragmentToConfirmationFragment(amount)
+				v.findNavController().navigate(action)
+			}
+			
+	- 9.4. Pass data between destinations:
+		+ way 1: using ViewModel for large data
+		+ way 2: using <argument>
+			- <action android:id="@+id/startMyFragment"
+				app:destination="@+id/myFragment">
+				<argument
+					android:name="myArg"
+					app:argType="integer"				// argType: primitive data, Parcelable, Serializable, Enum, resources (
+					android:defaultValue="1" />			// @null
+			</action>
+		+ way 3: using Safe-args (only using gradle)
+			- Send: override fun onClick(v: View) {
+					   val amountTv: EditText = view!!.findViewById(R.id.editTextAmount)
+					   val amount = amountTv.text.toString().toInt()
+					   val action = SpecifyAmountFragmentDirections.confirmationAction(amount)
+					   v.findNavController().navigate(action)
+					}
+			+ Recv:	val args: ConfirmationFragmentArgs by navArgs()  						// = getArguments() 
+					override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+						val tv: TextView = view.findViewById(R.id.textViewAmount)
+						val amount = args.amount
+						tv.text = amount.toString()
+					}
+					
+			+ using Safe-args global action:
+				
+		+ way 4: using Bundle
+			- Send: view.findNavController().navigate(R.id.confirmationAction, bundle)			// val bundle = bundleOf("amount" to amount)
+			- Recv:	arguments?.getString("amount")												// = getArguments() 
+		
+		+ way 5: Pass data to the start destination
+			- Send using NavHost: 			NavHostFragment.create(R.navigation.graph, args = bundle)
+			- Send using NavController:		navController.setGraph(R.navigation.graph, args = bundle)	/	navController.setGraph(navGraph, args)  (XML can not using attribute app:nav-graph  -> call .setGraph() -> call setGraph() 2 times)
+			- Recv: 						Fragment.getArguments()
+		
+		+ Note about ProGuard:  shrinking code = true
+			- using @Keep / -keepnames  for Parcelable, Serializable, Enum: to prevent being obfuscated as part of the minification process.
+			- @Keep class ParcelableArg : Parcelable { ... }	/	-keepnames class com.path.to.your.ParcelableArg (proguard-rules.pro)
+		
+	- 9.5. Animate transitions between destinations:
+		+ NavOptions: 			enter / exit / popEnter = / popExit = / popUpTo / popUpToInclusive
+		+ Navigator.Extras: 	FragmentNavigator.Extras /	ActivityNavigator.Extras 
+		
+		+ Fragment:  	FragmentNavigator.Extras											<fragment> <action android:id 	app:destination		app:enterAnim/exitAnim/popEnterAnim/popExitAnim/popUpTo/popUpToInclusive /> </fragment>
+			- val extras = FragmentNavigatorExtras(view1 to "hero_image")
+				view.findNavController().navigate(
+					R.id.confirmationAction,
+					null, // Bundle of args
+					null, // NavOptions
+					extras)
+			
+			- Animation & Animator
+			
+		+ Activity:		ActivityNavigator.Extras, ActivityOptionsCompat/ActivityOptions
+			- val options = ActivityOptionsCompat.makeSceneTransitionAnimation(activity, Pair.create(view1, "hero_image"))
+				val extras = ActivityNavigatorExtras(options)
+				view.findNavController().navigate(
+					R.id.details,
+					null, // Bundle of args
+					null, // NavOptions
+					extras)
+			
+			- Apply pop animations to activity transitions: finish() -> ActivityNavigator.applyPopAnimationsToPendingTransition(this)
+			
+			- startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this).toBundle())
+			- Activity.finishAfterTransition()
+		
+	- 9.6. Conditional navigate:
+		+ 
+		
+		
+// Animation & Animator: 		https://developer.android.com/guide/topics/resources/animation-resource?hl=vi
+	- Animation types: rotate, stretch, fade, slide, move, scale
+		+ fade: 	<alpha
+		+ slide:	<translate
+	
+	- Transition types: enter & exit
+		+ fade:			
+		+ slide:		
+		+ explode:		
+		
+	- Effects:
+		+ enter:
+		+ exit:
+		+ shared element transition:
+	
+	- Define xml: 
+		+ Animation:		res/anim 			-> res/anim/fade_out.xml		res/anim/slide_in.xml
+		+ Transitions:		res/transition		-> res/transition/fade.xml		res/transition/slide_right.xml
+	
+	- Using:
+		+  Fragment Animation: FragmentTransaction.setCustomAnimations(							--> supportFragmentManager.commit {
+											R.anim.slide_in, // enter							setCustomAnimations(enter, exit, popEnter, popExit)
+											R.anim.fade_out, // exit							replace()
+											R.anim.fade_in, // popEnter							addToBackStack(null)
+											R.anim.slide_out // popExit)					 }
+
+
+		+  Fragment Transition: TransitionInflater
+				- class FragmentA : Fragment() {
+					override fun onCreate(savedInstanceState: Bundle?) {
+						super.onCreate(savedInstanceState)
+						val inflater = TransitionInflater.from(requireContext())
+						enterTransition = inflater.inflateTransition(R.transition.slide_right)			-->	setEnterTransition()
+						exitTransition = inflater.inflateTransition(R.transition.fade)					-->	setExitTransition()
+					}
+				}
+				
+				- ViewCompat.setTransitionName(view, tag)		~ android:transitionName				--> supportFragmentManager.commit { addSharedElement(itemImageView, “hero_image”) }
+				
+		
+		+ 
+			
+
+
+
+		
+		
Index: app/src/main/assets/1.AndroidApp.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/1.AndroidApp.txt b/app/src/main/assets/1.AndroidApp.txt
new file mode 100644
--- /dev/null	(date 1731422051682)
+++ b/app/src/main/assets/1.AndroidApp.txt	(date 1731422051682)
@@ -0,0 +1,225 @@
+// Android App
+
+1. Overview
+	- Languages:			C++, Java/Kotlin
+	- Android Package: 		.apk					--> install app
+	- Android App Bundle:	.aab					--> 
+	
+	- 1 app ~ 1 sandbox: security privacy
+		+ Android = Linux with multi user:	1 app = 1 user
+		+ System define 1 UID for 1 app, app can not change UID. System set permission of all files in app and only app's UID can read those files
+		+ Each process has each VM -> mã của ứng dụng sẽ chạy độc lập với các ứng dụng khác.
+		+ Each app runs in each Linux process. System start process when any component of app is run, then kill process when there is no component run or get memmory for other app.
+		+ Minimum permission: app only read app component, not other app.
+		
+	- Shared data between 2 app:
+		+ 2 app share 1 UID ~ 2 apps - 1 process/1 VM				---		android:sharedUserId: set UID for app, Deprecated from API 29
+		+ Request Permissions
+			
+	- Components:
+		+ Activity:				start = Intent
+		+ Service:				start = Intent
+		+ BroadcasrReceiver:	start = Intent
+		+ COntentProvider:		start = ContentResolver
+		
+	- Manifest:
+		+ Declare: permissions, SDK, libs (Google map), hardware (camera, bluetooth, screen = <uses-feature ... />)
+		+ Declare Components:
+			- Intent filter
+			- 
+		
+	- Resources
+	- assets/:		AssetManager
+	
+	- gradle: 
+	
+
+2. App Resources: res/																	https://developer.android.com/guide/topics/resources/providing-resources?hl=vi
+	- anim/		animator/
+	- color/
+	- values/:					colors, dimens, strings, styles, arrrays				/ values-vi,-en-US
+	- drawable/	mipmap/																	/ mipmap-xxhdpi,-anydpi
+	- layout/	menu/
+	- raw/:						Resources.openRawResource(R.raw.filename)
+	- xml/:						Resources.getXML()
+	- font/:					R.font.filename
+	
+	- 2.1. Extend resource:			<resources_name>-<qualifier>-<qualifier> follow order below:
+		+ mcc-mnc:				mcc310, mcc310-mnc004
+		+ language: 			en-us, en-rUs 		/		ldrtl, ldltr
+		+ dimens:				sw320dp, w720dp, h720dp
+		+ screen size:			small, normal, large, xlarge
+		+ screen type:			round, notround		/		notouch, finger
+		+ HDR:					highdr, lowdr 								-- Dải động cao (HDR)
+		+ orientation:			land, port
+		+ UI mode:				car, desk, television, appliance (noo screen), watch, vrheadset (VR: kính thực tế ảo)
+		+ theme/mode:			night, nonight
+		+ screen dpi:			ldpi ~ 120, mdpi ~ 160, hdpi ~ 240, xhdpi ~ 320, xxhdpi ~ 480, xxxhdpi ~ 640, nodpi ~ for bitmap, tvdpi ~ 213, anydpi
+		+ keyboard:				keysexposed, keyshidden, keyssoft		/		nokeys, qwerty, 12key
+		+ navigate:				navexposed, navhidden			/		nonav, dpad, trackball, wheel
+		+ API:					v4, v26, v33
+	
+	- 2.2. Alias resource:
+		+ 1 icon - 2 xml
+		+ layout:		<merge> <include layout="@layout/main_layout" /> </merge>
+		+ 
+		
+	- 2.3. Using:
+		+ Code:			R.color.secondary_text_dark
+		+ XML:			android:textColor="@android:color/secondary_text_dark"
+		+ Reference:	android:textColor="?android:textColorSecondary"
+		
+	- 2.4. Configs changes:		onConfigurationChanged()
+		+ Activity: not recreate activity --> android:configChanges="orientation|screenSize|screenLayout|smallestScreenSize|  keyboardHidden  |locale|layoutDirection|  uiMode"
+		
+	- 2.5. Locale: language
+		+ Translate:  		not translate = <xliff:g> 														<xliff:g id="time" example="5 days">%1$s</xliff:g> until holiday
+		+ get locale:		Locale primaryLocale = context.getResources().getConfiguration().getLocales().get(0);			val primaryLocale: Locale = context.resources.configuration.locales[0]
+		+ testing locale:	
+			- gradle:	buildTypes.getByName("debug") { isPseudoLocalesEnabled = true }
+			- change language
+			
+		+ Support language:
+			- gradle:			defaultConfig { resConfigs("en", "es") }							--> format(locale, "Choose a %d-digit PIN", 4)
+			- Locale config: 	https://developer.android.com/guide/topics/resources/app-languages?hl=vi
+			- set locale default:
+				+ val appLocale: LocaleListCompat = LocaleListCompat.forLanguageTags("xx-YY")
+				  AppCompatDelegate.setApplicationLocales(appLocale)							// Call this on the main thread as it may require Activity.restart()
+				  mContext.getSystemService(LocaleManager.class).setApplicationLocales(new LocaleList(Locale.forLanguageTag("xx-YY")));		---		LocaleList currentAppLocales = mContext.getSystemService(LocaleManager.class).getApplicationLocales();
+	
+	- 2.6. Resource types:		https://developer.android.com/guide/topics/resources/animation-resource?hl=en
+		+ Animaton:
+			- Property animation: Animator		--> res/animator/		--> ValueAnimator, ObjectAnimator, or AnimatorSet = <animator>, <objectAnimator>, <set>
+				+ Using: 
+					- val set: AnimatorSet = AnimatorInflater.loadAnimator(myContext, R.animator.property_animator).apply { setTarget(myObject)  start() }
+			
+			- View animation:					--> res/anim/			
+				+ Tween animation: Animation 		res/anim/filename.xml				--> creates an animation by performing a series of transformations on a single image
+					- support: 					<set>, <alpha>, <scale>, <translate>, <rotate>
+					- custom interpolators:		res/anim/filename.xml
+						+ 
+					- Using:
+						+ val hyperspaceJump: Animation = AnimationUtils.loadAnimation(this, R.anim.hyperspace_jump)					image.startAnimation(hyperspaceJump)
+					
+				+ Frame animation: AnimationDrawable	res/drawable/filename.xml	 	--> showing a sequence of images in order			
+					- support: <animation-list>, <item>
+					- Using:
+						+ rocketImage.setBackgroundResource(R.drawable.animate_rocket_thrust)
+						  val rocketAnimation = rocketImage.background
+						if (rocketAnimation is Animatable) {
+							rocketAnimation.start()
+						}
+						
+		+ Color state:	ColorStateList				--> res/color/filename.xml				--> <selector>  <item android:state_xxx = "true|false" /> </selector>
+		
+		+ Drawable:		getDrawable(int)			--> res/drawable/filename.xml			https://developer.android.com/guide/topics/resources/drawable-resource?hl=en
+			- Bitmap file: 			BitmapDrawable 		(PNG, WEBP, JPG, or GIF)			<bitmap> 
+			- Nine-patch file:		NinePatchDrawable  	(.9.png)							<nine-patch			
+			- Layer list:			LayerDrawable											<layer-list> <item android:drawable ... /> </layer-list>
+			- State list:			StateListDrawable										<selector>  <item android:state_xxx = "true|false" /> </selector>
+			- Level list:			LevelListDrawable										<level-list> <item android:drawable ... /> </level-list>
+			- Transition drawable:	TransitionDrawable										<transition> <item android:drawable ... /> </transition>
+			- Inset drawable:		InsetDrawable											<inset			
+			- Clip drawable:		ClipDrawable											<clip
+			- Scale drawable:		ScaleDrawable											<scale
+			- Shape drawable:		GradientDrawable										<shape>	<corners> <gradient> <padding> <size> <solid> <stroke>  </shape>
+			
+		+ Layout:									--> res/layout/filename.xml
+		
+		+ Menu:										--> res/menu/filename.xml				<menu> <item>  <group> <item> </group>  <menu> ... </menu>  </menu>
+			+ Using:
+				- override fun onCreateOptionsMenu(menu: Menu): Boolean {
+					menuInflater.inflate(R.menu.example_menu, menu)
+					return true
+				}
+				- fun onGroupItemClick(item: MenuItem) { }
+				
+		+ String:								https://developer.android.com/guide/topics/resources/string-resource?hl=en
+			- String array:						<string-array name="array_name"> <item>xxxStr</item> </string-array>													resources.getStringArray(R.array.planets_array)
+			- Quantity strings (plurals):		<plurals name="plurals_name"> <item quantity=["zero"|"one"|"two"|"few"|"many"|"other"]>xxx %d Str</item> </plurals>		resources.getQuantityString(R.plurals.numberOfSongsAvailable, count, count)
+			- Format string:					<string name="welcome_messages">Hello, %1$s! You have %2$d new messages.</string>										var text = getString(R.string.welcome_messages, username, mailCount)
+			- Styling with HTML markup:			<string name="welcome">Welcome to <b>Android</b>!</string>
+			- Styling with spannables:
+			- Styling with annotations:			<string name="title">Best practices for <annotation font="title_emphasis">text</annotation> on Android</string>			val annotations = titleText.getSpans(0, titleText.length, Annotation::class.java)
+		
+		+ Style:									--> res/values/filename.xml
+			- Style:							<style name="style_name"> <item name="">style_value</item> </style>
+			 
+		+ Font:										--> res/font/filename.xml
+			- Bundled font:						<font-family> <font android:font/fontStyle/fontWeight = "" /> </font-family>
+			- Downloadable font: 				<font-family android:fontProviderXXX  android:fontProviderYYY />
+			
+		+ More types:
+			- Boool:	
+			- Dimension:
+			- ID:
+			- Integer
+			- Integer array:
+			- Typed array:						
+			
+	
+3. Manifest:									https://developer.android.com/guide/topics/manifest/manifest-intro?hl=vi
+	- App level:								<manifest>																	<application>				
+	- Components:								<activity>, <activity-alias>, <provider>, <receiver>, <service>				<intent-filter>, <action>, <category>, <data>, <meta-data>
+	- Device compatibility:						<compatible-screens>
+	- Permissions:								<path-permission>, <permission>, <permission-group>, <permission-tree>		<uses-permission>, <uses-permission-sdk-23>											<grant-uri-permission>
+	- Support:									<supports-gl-texture>, <supports-screens>									<uses-configuration>, <uses-feature>, <uses-sdk>(min/maxSdk: overriden by gradle)
+	- Library:									<uses-library>, <uses-native-library>
+	- Access other apps:						<queries>
+	- Test:										<instrumentation>
+	
+	- Limit:									<package> - 1000			<meta-data> - 1000				<uses-library> - 1000
+		+ Attribute Length:						name - 1024					versionName - 1024				host - 255								mimeType - 255
+		
+	
+	- Details:
+		+ <manifest>:
+			- android:sharedUserId				-	set same UID for many app, @Deprecated from API 29				 	=android:sharedUserLabel									<-- android:sharedUserMaxSdkVersion="32"
+			- android:targetSandboxVersion		- 	1 (api < 26) [can shared UID]										2 (api >= 26) [new SELinux sandbox, usesCleartextTraffic = false, Không cho phép chia sẻ mã nhận dạng người dùng]
+			- android:installLocation			- 	"auto" | "internalOnly" | "preferExternal"
+			
+			- 
+		+ <application>
+			- 
+			- 
+		+ <activity>
+			-
+			-
+		+ 
+	
+	
+4. App Architecture
+	- 4.1. Overview
+	- 4.2. Modularization
+	- 4.3. Architecture Components
+			+  save state off UI: reboot, system kill, recent
+				+ 1. Viewmodel
+				+ 2. Save state:
+					+ Jetpack Compose: rememberSaveable.
+					+ Khung hiển thị (View): API onSaveInstanceState().
+					+ ViewModel: SavedStateHandle.
+				3. Local storage: db, share preference
+				4. SavedStateRegistry:	Activity, Fragment			
+	- 4.4. App entry points
+	- 4.5. App Naigation
+	- 4.6. Dependencies Injection
+	- 4.7. App Startup
+	
+5. Devices:
+	- Compatible:
+	- Phone & Tablet
+	- Responsive
+	- Wear
+	- TV
+	- Chrome OS
+	- SDK
+
+
+6. Google Play
+	- 
+
+
+7. Core areas
+
+
+8. Build for enterprise
Index: app/src/main/assets/KotlinDoc/21.DataClass.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/KotlinDoc/21.DataClass.kt b/app/src/main/assets/KotlinDoc/21.DataClass.kt
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/KotlinDoc/21.DataClass.kt	(date 1731353706000)
@@ -0,0 +1,45 @@
+    /* Data class:
+    * - POJOs (Plain Old Java Objects)
+    * - Immutability: mặc định là final và không thể khai báo với từ khóa open (fields có thể thay đổi với 'var' nhưng ko nên)
+    * - auto-generate constructor, getter, setter, equals, hashCode, toString
+    * */
+
+    // 1. Simple: auto-generate constructor, getter, setter, equals, hashCode, toString
+    data class Person(val name: String, val age: Int, val email: String, val phone: Long)
+
+    // 2. Default and named arguments:
+    data class Person(val name: String = "default name", val age: Int = 30,
+                      val email: String = "dummy email", val phone: Long = 1234567890)
+    // Using default arguments & named arguments
+    val person1 :Person = Person("name", 25, "email@gmail.com", 555544448)
+    val person2 :Person = Person()
+    val person3 :Person = Person("name", 25)
+    val person4 :Person = Person(name = "name", phone = 9876543210)
+
+    // 3. Muốn một phiên bản của một đối tượng khác chỉ với một vài thay đổi -> copy()
+    val person1Copy = person1.copy()
+    val person1With30 = person1.copy(age = 30)
+    val person4WithEmail = person4.copy(email = "person4@gmail.com")
+
+    // 4. Inheritance: data class is final, not open -> must using interface to inherit
+    interface Person {  // >< Java interface has not any fields -> sub class must override all fields, nếu ko sẽ bị Compilation error
+        val name: String
+        val age: Int
+        val email: String
+        fun hasResponsibilities() : Boolean
+    }
+
+    data class Adult(override val name: String, override val age: Int, override val email: String) : Person {
+        val isMarried: Boolean = false      // new field
+        val hasKids: Boolean = false        // new field
+        override fun hasResponsibilities(): Boolean = true
+    }
+
+    data class Child(override val name: String, override val age: Int, override val email: String = "") : Person {
+        val isInSchool: Boolean = true      // new field
+        override fun hasResponsibilities(): Boolean = false
+    }
+
+    // 5. Parcelable: @Parcelize, from Kotlin 1.1.4
+    @Parcelize
+    data class PersonParcelize(val name: String, val age: Int, val email: String, val phone: Long) : Parcelable
Index: app/src/main/assets/JavaDoc/JavaNative.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/assets/JavaDoc/JavaNative.java b/app/src/main/assets/JavaDoc/JavaNative.java
new file mode 100644
--- /dev/null	(date 1731353706000)
+++ b/app/src/main/assets/JavaDoc/JavaNative.java	(date 1731353706000)
@@ -0,0 +1,86 @@
+1. JDK: 
+- JVM: Java Virtual Machine -> Thực thi bytecode Java, trên mọi nền tảng = chuyển bytecode java sang mã máy -> viết 1 lần, chạy mọi nơi. (Write Once, Run Anywhere - WORA)
+    + Máy ảo: mô phỏng một máy tính chạy trên một máy tính thực, cho phép các ứng dụng Java chạy trên bất kỳ thiết bị nào có JVM mà không cần phải viết lại mã cho mỗi hệ điều hành cụ thể.
+    + Độc lập với Nền tảng: JVM giúp ứng dụng Java có thể chạy trên bất kỳ nền tảng nào mà không cần sửa đổi.
+    + Thực thi Bytecode: Java app -> compiler -> bytecode -> JVM -> mã máy. JVM biện dịch bytecode thành mã máy = process Just-In-Time (JIT) compilation
+    + Quản lý Bộ Nhớ: JVM quản lý bộ nhớ cho các chương trình Java, bao gồm cả việc phân bổ bộ nhớ cho các đối tượng và thu gom rác (garbage collection) để giải phóng bộ nhớ không còn được sử dụng.
+    + Bảo mật: JVM cung cấp một lớp bảo mật giữa ứng dụng Java và hệ điều hành máy chủ, giúp ngăn chặn mã độc hại và cung cấp một môi trường thực thi an toàn cho ứng dụng.
+    + Tích hợp Thư viện: Cung cấp một tập hợp các thư viện tiêu chuẩn có thể được sử dụng bởi các ứng dụng Java, giúp tăng tốc độ phát triển ứng dụng và giảm thiểu mã cần được viết.
+
+    + Garbage Collection (GC):
+      - Đánh dấu và Dọn dẹp (Mark and Sweep)
+      - Generational Collection: Bộ nhớ heap được chia thành các khu vực thế hệ khác nhau (ví dụ: Young Generation, Old Generation), và GC sẽ tập trung vào việc dọn dẹp các đối tượng ở "Young Generation" thường xuyên hơn, vì chúng có khả năng chết trẻ hơn.
+      - Tối ưu hóa Garbage Collection:
+          + Tuning GC: Các tham số JVM có thể được điều chỉnh để tối ưu hóa hoạt động của GC, tùy thuộc vào loại ứng dụng và yêu cầu hiệu suất.
+          + Sử dụng các Collector khác nhau: Java cung cấp nhiều loại garbage collectors (ví dụ: Parallel GC, Concurrent Mark Sweep (CMS) GC, Garbage-First (G1) GC), mỗi loại có những ưu và nhược điểm riêng.
+      - Quản lý bộ nhớ tự động, Ngăn chặn rò rỉ bộ nhớ, Tăng hiệu suất và ổn định.
+
+    + Class Loader: là một phần của Java Virtual Machine (JVM) chịu trách nhiệm tải các lớp (class) vào bộ nhớ khi chương trình Java chạy.
+      - Bootstrap Class Loader: Là class loader cấp cao nhất, chịu trách nhiệm tải các lớp cốt lõi của Java API nằm trong thư viện runtime của Java (rt.jar)
+      - Extension Class Loader: Tải các lớp từ các thư viện mở rộng của Java, nằm trong thư mục extensions (jre/lib/ext hoặc bất kỳ thư mục nào được chỉ định bởi hệ thống thuộc tính java.ext.dirs).
+      - System/Application Class Loader: Tải các lớp từ classpath của ứng dụng, bao gồm các lớp được định nghĩa bởi người dùng.
+
+      - Cơ chế Delegation Model: Class loader trong Java tuân theo mô hình ủy quyền (Delegation Model), nghĩa là khi một class loader nhận được yêu cầu tải lớp, nó sẽ chuyển yêu cầu đó lên class loader cha trước khi tự mình cố gắng tải lớp. 
+                                  Quá trình này tiếp tục cho đến khi đạt đến Bootstrap Class Loader. Nếu lớp không được tìm thấy trong quá trình này, các class loader sẽ theo thứ tự ngược lại cố gắng tải lớp đó.
+      - Tùy chỉnh Class Loader: Java cũng cho phép bạn tạo custom class loader bằng cách kế thừa lớp ClassLoader. 
+                                Điều này hữu ích khi bạn muốn mở rộng cơ chế tải lớp mặc định của Java, ví dụ như để tải các lớp từ một nguồn không phải là hệ thống file (như mạng, các tập tin được mã hóa, v.v.)
+
+- JRE: Java Runtime Environment, là môi trường thực thi cần thiết để chạy ứng dụng và applet được viết bằng Java, bao gồm: (dành cho user chỉ muốn chạy ứng dụng java mà ko dev)
+    + JVM 
+    + Standard APIs: bao gồm các công cụ cho UI, xử lý dữ liệu, kết nối mạng, và nhiều chức năng khác.
+    + Tệp hỗ trợ thực thi ứng dụng java: tệp cấu hình và các tài nguyên hệ thống.
+    + Plugin Cho Trình Duyệt: Trong một số phiên bản JRE, nó bao gồm plugin cho trình duyệt, cho phép các applets Java chạy trực tiếp trong trình duyệt web.
+
+- JDK: Java Development Kit, cung cấp môi trường thực thi cần thiết để phát triển ứng dụng và applet được viết bằng Java, bao gồm:
+    + JRE:
+    + Java compiler: javac
+    + Công cụ đóng gói: jar
+    + Công cụ bổ sung: debug, JavaDoc, công cụ phát triển nâng cao
+
+2. JNI: giúp Java gọi code từ ngôn ngữ khác và ngược lại, có tính 2 chiều, nhưng làm mất đặc điểm WORA của java
+-
+
+
+3. Liên kết Java & C++ bằng JNI
+
+3.1. Viết phương thức native trong java Class: 
+  - HelloWorld.java
+    + private static native String getHelloString(Type params*);
+    + static {
+          System.loadLibrary("HelloWorld"); // load file HelloWorld.dll 
+      }
+
+3.2. Dịch java Class ra file .class = command javac: 
+  - "javac HelloWorld.java" -> HelloWorld.class
+
+3.3. Tạo file .h trong C++: 
+  - "javac -h . HelloWorld.java" -> HelloWorld.h
+
+  - HelloWorld.h: #include <jni.h>
+    + jni.h: in folder "/*/jdk/include/"
+      - #include "jni_md.h", <stdio.h>, <stdarg.h>
+      - define jint = , jstring = , JNINativeInterface_
+    + jni_md.h: in folder "/*/jdk/include/win32"
+    + format: JNIEXPORT jType JNICALL Java_package_name_ClassName_methodName(JNIEnv *env, jobject obj, jType params*);
+
+3.4. Viết hàm/lớp/phương thức C++ mà sẽ được gọi từ phương thức native trong Java đã khai báo ở trên:
+  - HelloWorld.cpp: #include <HelloWorld.h>
+    + method: JNIEXPORT jType JNICALL Java_package_name_ClassName_methodName(JNIEnv *env, jobject obj, jType params*) { // do something }
+
+3.5.  Dịch hàm/lớp/phương thức C++ trên thành file thư viện liên kết động .dll (Windows) hoặc .so (Linux)
+  - 2 step: 
+    + g++ tao file object:
+      - g++ -I "path_file_header" -c <fileName.cpp> -o <fileObject.o>
+    + g++ link file object thanh file .dll (.so):
+      - g++ -Wl,--add-stdcall-alias -shared -o <tên_file_dll> <tên_file_object>
+  
+3.5. Load file thư viện đó trong main ở phía Java và sử dụng
+  - java -classpath . -Djava.library.path=<đường_dẫn_đến_file_dll> <tên_lớp_main>
+
+3.6. Create Folder "jniLibs" inside "src/main/" -> create sub folders: arm64-v8a, armeabi-v7a, x86 -> Put all your .so libraries inside "src/main/jniLibs/armeabi-v7a, x86" folder
+- add to build.gradle/android { 
+  sourceSets {
+        main {
+            jniLibs.srcDirs = ['src/main/jniLibs']
+        }
+    }
diff --git a/app/src/main/assets/ComposeDoc/Compose.txt b/app/src/main/assets/ComposeDoc/Compose.txt
new file mode 100644
